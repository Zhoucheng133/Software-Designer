<!DOCTYPE html>
<html>
<head>
<title>3.数据库系统.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #ff0000; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F">数据库系统</h1>
<h2 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F-%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%B0%84">数据库的三级模式-两级映射</h2>
<ul>
<li>
<h3 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F">数据库的三级模式</h3>
三级模式包括：<br>
<mark><strong>内模式：和物理数据库联系，用于管理如何存储数据<br>
概念模式：对应数据库的表，将数据库划分为若干个表<br>
外模式：对应数据库的视图，对数据更加灵活的方式</strong></mark></li>
<li>
<h3 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%B0%84">数据库的两级映射</h3>
两级映射（用于表示两两模式的关系）：<br>
<mark><strong>概念模式-内模式映射：内部存储形式和表的形式的映射关系<br>
外模式-概念模式映射：表和视图的映射关系</strong></mark></li>
</ul>
<img src="./p13.png" width = "400" height = "350">
<h2 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1">数据库的设计</h2>
<ul>
<li>
<h3 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B">数据库设计流程</h3>
<p><mark><strong>1.需求分析</strong><br>
<strong>2. 概念结构设计</strong>（<code>主要做ER模型</code>）<br>
<strong>3. 逻辑结构设计</strong>（<code>转换成关系模式</code>)<br>
<strong>4. 物理设计（加入DBMS特性）</strong></mark></p>
<img src="./p14.png" width = "370" height = "350">
</li>
<li>
<h3 id="er%E6%A8%A1%E5%9E%8B">ER模型</h3>
<ul>
<li>
<p>各种表示：</p>
<ul>
<li><mark><strong>方框：实体</strong><mark></li>
<li><mark><strong>椭圆：属性</strong></mark></li>
<li><mark><strong>菱形：联系/关系</strong></mark></li>
</ul>
</li>
<li>
<p>集成方法：</p>
<ul>
<li>逐步集成：用累加的方法一次集成两个局部E-R图</li>
<li>多个局部E-R图一次集成</li>
</ul>
</li>
<li>
<p>一个实体转换为一个关系模式：</p>
<ul>
<li>1:1联系<br>
对于1:1的模型，可以将联系放在任何一个实体中<br>
<mark><strong>即最少需要2个关系模型</strong></mark></li>
<li>1:n联系<br>
对于1:n的模型，可以将联系放在<mark><strong>对应多个的实体中<br>
即最少需要2个关系模型</strong></mark></li>
<li>m:n联系<br>
对于m:n的模型，<mark><strong>两边都需要转换成各自的实体，并且联系也需要单独创建一个实体<br>
即最少需要3个关系模型</strong></mark></li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>例：在数据库逻辑结构的设计中，将E-R模型转换成关系模型应遵循相关原则。对于三个不同的实体集和它们之间的多对多联系m:n:p，最少可转换成___个关系模型
</div></code></pre>
<img src="./p15.png" width = "300" height = "200">
<pre class="hljs"><code><div>解：由题可知，这是一个多对多的模型，因此需要(1+1+1)+1=4个关系模式
注意前面三个1是三个实体，最后一个1是联系需要转换的关系模式
</div></code></pre>
</li>
<li>
<h3 id="%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0">关系代数</h3>
<p>关系代数的几种形式：<mark><b>并、交、差、笛卡尔积、投影、选择、联接</b></mark>
例如下述两个关系表S1和S2</p>
<table>
<tr>
  <td colspan="3" align="center">关系S1</td>
  <td></td>
  <td colspan="3" align="center">关系S2</td>
</tr>
<tr>
  <td><b>Sno</b></td>
  <td><b>Sname</b></td>
  <td><b>Sdept</b></td>
  <td></td>
  <td><b>Sno</b></td>
  <td><b>Sname</b></td>
  <td><b>Sdept</b></td>
</tr>
<tr>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
  <td></td>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0003</td>
  <td>Candy</td>
  <td>IS</td>
  <td></td>
  <td>No0008</td>
  <td>Katter</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0004</td>
  <td>Jam</td>
  <td>IS</td>
  <td></td>
  <td>No0021</td>
  <td>Tom</td>
  <td>IS</td>
</tr>
</table>
<ul>
<li>
<p>并集<br>
那么S1∪S2（S1并S2）：<mark><strong>合并相同项，并组合两个表</strong></mark></p>
<table>
<tr>
  <td colspan="3" align="center">S1∪S2</td>
</tr>
<tr>
  <td><b>Sno</b></td>
  <td><b>Sname</b></td>
  <td><b>Sdept</b></td>
</tr>
<tr>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0003</td>
  <td>Candy</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0004</td>
  <td>Jam</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0008</td>
  <td>Katter</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0021</td>
  <td>Tom</td>
  <td>IS</td>
</tr>
</table>
</li>
<li>
<p>交集<br>
S1∩S2（S1交S2）：<mark><strong>只显示两个表中相同部分</strong></mark></p>
<table>
<tr>
  <td colspan="3" align="center">S1∩S2</td>
</tr>
<tr>
  <td><b>Sno</b></td>
  <td><b>Sname</b></td>
  <td><b>Sdept</b></td>
</tr>
<tr>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
</tr>
</table>
</li>
<li>
<p>差集<br>
S1-S2（S1与S2的差集）：S1有，但是S2没有的（<mark><strong>被减数有但是减数没有的</strong></mark>）</p>
<table>
<tr>
  <td colspan="3" align="center">S1-S2</td>
</tr>
<tr>
  <td><b>Sno</b></td>
  <td><b>Sname</b></td>
  <td><b>Sdept</b></td>
</tr>
<tr>
  <td>No0003</td>
  <td>Candy</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0004</td>
  <td>Jam</td>
  <td>IS</td>
</tr>
</table>
</li>
<li>
<p>笛卡尔积<br>
每一个S1对应S2，因此如果是3x3的S1和3x3的S2做笛卡尔积的运算，那么结果为9x9的表，<mark><strong>即表A每一条数据分别对应表B的每一条数据</strong></mark></p>
<table>
<tr>
  <td colspan="6" align="center">S1 x S2（笛卡尔积）</td>
</tr>
<tr>
  <td><b>Sno</b></td>
  <td><b>Sname</b></td>
  <td><b>Sdept</b></td>
  <td><b>Sno</b></td>
  <td><b>Sname</b></td>
  <td><b>Sdept</b></td>
</tr>
<tr>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
  <td>No0008</td>
  <td>Katter</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
  <td>No0021</td>
  <td>Tom</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0003</td>
  <td>Candy</td>
  <td>IS</td>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0003</td>
  <td>Candy</td>
  <td>IS</td>
  <td>No0008</td>
  <td>Katter</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0003</td>
  <td>Candy</td>
  <td>IS</td>
  <td>No0021</td>
  <td>Tom</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0004</td>
  <td>Jam</td>
  <td>IS</td>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0004</td>
  <td>Jam</td>
  <td>IS</td>
  <td>No0008</td>
  <td>Katter</td>
  <td>IS</td>
</tr>
<tr>
  <td>No0004</td>
  <td>Jam</td>
  <td>IS</td>
  <td>No0021</td>
  <td>Tom</td>
  <td>IS</td>
</tr>
</table>
</li>
<li>
<p>投影<br>
投影需要选择对什么进行投影<br>
类似于筛选操作，<mark><strong>需要投影的内容进行现实，不需要投影的内容则不予显示（投影的内容是筛选列）</strong></mark><br>
下表以对Sno和Sname做投影</p>
<table>
<tr>
  <td colspan="2" align="center">对S1中的Sno和Sname进行的投影</td>
</tr>
<tr>
  <td><b>Sno</b></td>
  <td><b>Sname</b></td>
</tr>
<tr>
  <td>No0001</td>
  <td>Marry</td>
</tr>
<tr>
  <td>No0003</td>
  <td>Candy</td>
</tr>
<tr>
  <td>No0004</td>
  <td>Jam</td>
</tr>
</table>
<p><mark><strong>p.s.上表记作π<sub>1,2</sub>(S1)</strong></mark>
<br><br></p>
</li>
<li>
<p>选择<br>
<mark><strong>选择相当于对行进行筛选，不需要的记录则不予显示</strong></mark><br>
下表对S1中Sno=No0003的内容进行选择</p>
<table>
  <tr>
  <td colspan="3" align="center">对S1中Sno=No0003的内容进行选择</td>
  </tr>
  <tr>
    <td><b>Sno</b></td>
    <td><b>Sname</b></td>
    <td><b>Sdept</b></td>
  </tr>
  <tr>
    <td>No0003</td>
    <td>Candy</td>
    <td>IS</td>
  </tr>
<table>
<p><mark><strong>p.s.上表记作σ<sub>1=No0003</sub>(S1)或者σ<sub>Sno=No0003</sub>(S1)</strong></mark></p>
</li>
<li>
<p>连接<br>
<mark><strong>将两个表中相同实体的不同属性进行连接，如果无法连接的数据不予显示</strong></mark><br>
例如下述两表</p>
<table>
<tr>
  <td colspan="3" align="center">关系S1</td>
  <td></td>
  <td colspan="2" align="center">关系S1</td>
</tr>
<tr>
  <td><b>Sno</b></td>
  <td><b>Sname</b></td>
  <td><b>Sdept</b></td>
  <td></td>
  <td><b>Sno</b></td>
  <td><b>Age</b></td>
</tr>
<tr>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
  <td></td>
  <td>No0001</td>
  <td>23</td>
</tr>
<tr>
  <td>No0003</td>
  <td>Candy</td>
  <td>IS</td>
  <td></td>
  <td>No0008</td>
  <td>21</td>
</tr>
<tr>
  <td>No0004</td>
  <td>Jam</td>
  <td>IS</td>
  <td></td>
  <td>No0021</td>
  <td>22</td>
</tr>
<table>
<p>连接两个表:</p>
<table>
<tr>
  <td align="center" colspan="4">将S1与S2连接</td>
</tr>
<tr>
  <td><b>Sno</b></td>
  <td><b>Sname</b></td>
  <td><b>Sdept</b></td>
  <td><b>Age</b></td>
</tr>
<tr>
  <td>No0001</td>
  <td>Marry</td>
  <td>IS</td>
  <td>23</td>
</tr>
</table>
<p><mark><strong>p.s.上表记作S1▷◁S2(S1·Sno=S2·Sno)</strong></mark></p>
</li>
</ul>
</li>
</ul>
<h2 id="%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA">规范化理论</h2>
<ul>
<li>
<h3 id="%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96">函数依赖</h3>
<ul>
<li>
<p>部分函数依赖<br>
<img src="./p16.png" width = "200" height = "126"></p>
<p>其中A能直接确定C，因此A和B联合即可以确定C<br>
<strong><mark>即组件的一个部分就可以确定属性</mark></strong></p>
</li>
<li>
<p>传递函数依赖<br>
<img src="./p17.png" width = "200" height = "126"></p>
<p>其中A可以确定B，B可以确定C，因此A可以确定C<br>
<strong><mark>即确定的关系可以传递</mark></strong><br>
<strong><mark>但是不能反向确定（如果可以反向，那么两者便可以等价）</mark></strong></p>
</li>
</ul>
</li>
<li>
<h3 id="%E9%94%AE">键</h3>
<ul>
<li>超键<br>
<strong><mark>唯一标示元祖<br>
可能存在冗余属性</mark></strong></li>
<li>候选键<br>
<strong><mark>同样也唯一标示元祖<br>
但是不可能存在冗余属性</mark></strong><br>
<strong>超键去除冗余的属性之后便可以得到候选键</strong><pre class="hljs"><code><div>备注：例如(学号)和(学号,姓名)可以都可以称之为超键，但是(学号,姓名)只能作为超键，不能当作是候选键，因为有姓名这样的冗余属性
</div></code></pre>
</li>
<li>主键<br>
<mark><strong>主键相较于候选键只能有一个</strong></mark></li>
<li>外键<br>
<mark><strong>其他关系的主键</strong></mark></li>
</ul>
<p>超键-&gt;（去除冗余信息）候选键-&gt;（选择一个）主键</p>
<ul>
<li>
<p>求候选键<br>
解法：<br>
<mark><strong>1. 画图关系图，A-&gt;B，A可以确定B<br>
2. 找出入度为0的结点<br>
3. 如果通过这个结点可以遍历整个图，那么这个结点就是候选键</strong></mark></p>
<pre class="hljs"><code><div>例1：给定关系R（A1，A2，A3，A4）上的函数依赖集P={A1-&gt;A2，A3-&gt;A2，A3-&gt;A2，A2-&gt;A3，A2-&gt;A4}，R的候选关键字为___
</div></code></pre>
<img src="./p18.png" width = "300" height = "180">
<pre class="hljs"><code><div>解：候选关键字为A1
</div></code></pre>
<pre class="hljs"><code><div>例2：关系模型P如图依赖关系，求候选键？
</div></code></pre>
<img src="./p19.png" width = "300" height = "180">
<pre class="hljs"><code><div>解：左下角小图可得候选键为C
图中央的大图候选键为A、B、D
</div></code></pre>
<pre class="hljs"><code><div>例3：关系模型P如图依赖关系，求候选键？
</div></code></pre>
<img src="./p20.png" width = "300" height = "180">
<pre class="hljs"><code><div>解：候选关键字为A和B
</div></code></pre>
</li>
</ul>
</li>
<li>
<h3 id="%E8%8C%83%E5%BC%8F">范式</h3>
<p>范式：级别最低的是第一范式(1NF)，其次是第二范式(2NF)、第三范式(3NF)……最高级是BCNF<br>
其中需要达到第二范式必须达到第一范式，以此类推<br>
<strong><mark>即如果达到级别高的范式，必须要先达到级别低的范式</mark></strong><br>
其中第一范式<mark><strong>属性值都是不可分的原子值</strong></mark></p>
<p><strong><mark>级别越高，规范程度越高，更有可能解决插入异常、删除异常、数据冗余的问题</mark></strong></p>
<ul>
<li>
<p>第一范式（1NF）<br>
<strong><mark>在关系模式R中，当且仅当所有域只包含原子值，即每个分量都是不可再分的数据项，则称R是第一范式</mark></strong><br>
例如下述表:</p>
<table>
<tr>
  <td rowspan="2"><b>系名称</b></td>
  <td colspan="2"><b>高级职称人数</b></td>
</tr>
<tr>
  <td>教授</td>
  <td>副教授</td>
</tr>
<tr>
  <td>计算机系</td>
  <td>6</td>
  <td>10</td>
</tr>
<tr>
  <td>电子系</td>
  <td>3</td>
  <td>5</td>
</tr>
</table>
<p>上表不满足1NF，因为高级职称人数还可以继续拆分：</p>
<table>
<thead>
<tr>
<th style="text-align:center">系名称</th>
<th style="text-align:center">教授</th>
<th style="text-align:center">副教授</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">计算机系</td>
<td style="text-align:center">6</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">电子系</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>第二范式（2NF）<br>
<mark><strong>第二范式的前提必须要是第一范式，并且每一个非主属性完全依赖主键（不存在部分依赖）时，则称R是第二范式（2NF）</strong></mark><br>
例如下述表中（红色加粗字体为候选键）</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>Sno</code></th>
<th style="text-align:center"><code>Cno</code></th>
<th style="text-align:center">Grade</th>
<th style="text-align:center">Credit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S01</td>
<td style="text-align:center">C01</td>
<td style="text-align:center">75</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">S02</td>
<td style="text-align:center">C01</td>
<td style="text-align:center">92</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">S03</td>
<td style="text-align:center">C01</td>
<td style="text-align:center">87</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">S04</td>
<td style="text-align:center">C01</td>
<td style="text-align:center">55</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">S01</td>
<td style="text-align:center">C02</td>
<td style="text-align:center">87</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">S02</td>
<td style="text-align:center">C02</td>
<td style="text-align:center">95</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">S01</td>
<td style="text-align:center">C03</td>
<td style="text-align:center">94</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
</tr>
</tbody>
</table>
<p><strong><code>(上表属于1NF)</code></strong><br>
<strong><code>(上表存在数据冗余)</code></strong><br>
<strong><mark>上述表中Sno和Cno为候选键，但是Credit只依赖于Cno而不依赖于Sno，则上表不是第二范式，正确做法应该将其拆分</mark></strong><br>
上述表需要将Cno和Credit提取出来建立新的关系表，原表中去除Credit这一列<br>
<strong><mark>主键只有一个的时候一定是第二范式</mark></strong></p>
</li>
<li>
<p>第三范式（3NF）<br>
<strong><mark>第三范式的前提必须是第二范式（2NF），且没有非主属性传递依赖于码时，则称其为第三范式</mark></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong><code>Sno</code></strong></th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Dno</th>
<th style="text-align:center">Dname</th>
<th style="text-align:center">Loca</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S01</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">D01</td>
<td style="text-align:center">CS</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">S02</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">D01</td>
<td style="text-align:center">CS</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">S03</td>
<td style="text-align:center">王五</td>
<td style="text-align:center">D01</td>
<td style="text-align:center">CS</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">S04</td>
<td style="text-align:center">赵六</td>
<td style="text-align:center">D02</td>
<td style="text-align:center">IS</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p><strong><code>(上述表为2NF)</code></strong><br>
<strong><code>(上表存在数据冗余)</code></strong><br>
上述表中Sno是主键，因此这个表肯定属于第二范式(2NF)，但是存在大量的重复信息，因此需要将Dno、Dname和Loca提取出来单独列表。</p>
</li>
<li>
<p>BC范式（BCNF）<br>
<strong><mark>BC范式的前提是第三范式，每个非主属性既不部分依赖于码也不传递依赖于码</mark></strong></p>
</li>
</ul>
<pre class="hljs"><code><div>例：某公司的部门（部门号，部门名，负责人，电话）、商品（商品号，商品名称，单价，库存量）和职工（职工号，姓名，住址）三个实体之间的关系如表1、表2和表3所示，假设每个部门有一位负责人和一部电话，但有若干名员工；每种商品只能由一个部门负责销售。部门关系不属于第三方范式的原因是___。如果用户要求得到表4所示的结构，需要___，并增加关系模式___。
第二空选项：
A.修改表1，增加职工号
B.修改表2，增加职工号
C.修改表2，增加部门号
D.修改表3，增加部门号
第三空选项：
A.销售（职工号，商品号，日期，数量）
B.销售（职工号，商品名称，商品号，数量）
C.销售（职工号，部门号，日期，数量）
D.销售（职工号，部门号，商品号，日期）
</div></code></pre>
<p><strong><code>表1:</code></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">部门号</th>
<th style="text-align:center">部门名</th>
<th style="text-align:center">负责人</th>
<th style="text-align:center">电话</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">家电部</td>
<td style="text-align:center">E002</td>
<td style="text-align:center">1001</td>
</tr>
<tr>
<td style="text-align:center">002</td>
<td style="text-align:center">百货部</td>
<td style="text-align:center">E026</td>
<td style="text-align:center">1002</td>
</tr>
<tr>
<td style="text-align:center">003</td>
<td style="text-align:center">食品部</td>
<td style="text-align:center">E030</td>
<td style="text-align:center">1003</td>
</tr>
</tbody>
</table>
<br>
<p><strong><code>表2:</code></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">商品号</th>
<th style="text-align:center">商品名称</th>
<th style="text-align:center">单价</th>
<th style="text-align:center">库存量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">30023</td>
<td style="text-align:center">微机</td>
<td style="text-align:center">4800</td>
<td style="text-align:center">26</td>
</tr>
<tr>
<td style="text-align:center">30034</td>
<td style="text-align:center">打印机</td>
<td style="text-align:center">1650</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">30101</td>
<td style="text-align:center">毛巾</td>
<td style="text-align:center">10</td>
<td style="text-align:center">106</td>
</tr>
<tr>
<td style="text-align:center">30102</td>
<td style="text-align:center">牙刷</td>
<td style="text-align:center">10</td>
<td style="text-align:center">106</td>
</tr>
</tbody>
</table>
<p><strong><code>表3:</code></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">职工号</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">住址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">E001</td>
<td style="text-align:center">王军</td>
<td style="text-align:center">南京路</td>
</tr>
<tr>
<td style="text-align:center">E002</td>
<td style="text-align:center">李晓斌</td>
<td style="text-align:center">淮海路</td>
</tr>
<tr>
<td style="text-align:center">E021</td>
<td style="text-align:center">余飞</td>
<td style="text-align:center">江西路</td>
</tr>
<tr>
<td style="text-align:center">E026</td>
<td style="text-align:center">田晓菲</td>
<td style="text-align:center">江西路</td>
</tr>
<tr>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
</tr>
</tbody>
</table>
<p><strong><code>表4:</code></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">职工号</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">部门号</th>
<th style="text-align:center">月销售额</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">E001</td>
<td style="text-align:center">王军</td>
<td style="text-align:center">家电部</td>
<td style="text-align:center">528900</td>
</tr>
<tr>
<td style="text-align:center">E002</td>
<td style="text-align:center">李晓斌</td>
<td style="text-align:center">家电部</td>
<td style="text-align:center">360000</td>
</tr>
<tr>
<td style="text-align:center">E021</td>
<td style="text-align:center">余飞</td>
<td style="text-align:center">百货部</td>
<td style="text-align:center">12500</td>
</tr>
<tr>
<td style="text-align:center">E026</td>
<td style="text-align:center">田晓菲</td>
<td style="text-align:center">食品部</td>
<td style="text-align:center">15000</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>解：1.只消除了非主属性部分函数依赖而没有消除传递函数依赖，而没有消除传递函数依赖
备注：在表1中，部门号只对应一个部门名称，但是部门号可以对应部门名的同时，部门名有对应负责人，负责人又对应电话（传递依赖）
2.选择C:修改表2，增加部门号
备注：从修改复杂程度来说选择修改表2
3.选择A:销售（职工号，商品号，日期，数量）
B选项中商品名称和商品号互相依赖
C职工号和部门号互相依赖
D同上
</div></code></pre>
<p><br><br><br><br><br><br></p>
</li>
<li>
<h3 id="%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3">模式分解</h3>
<p>两种函数分解：<mark><strong>保持函数依赖分解</strong></mark>和<mark><strong>无损分解</strong></mark></p>
<ul>
<li>
<p>保持函数分解<br>
<strong><mark>在分解的同时也能表现出原有各个模式中的依赖关系</mark></strong><br>
例如A-&gt;B-&gt;C关系的R(A,B,C)分解为R1(A,B)，R2(B,C)，那么可以说R1，R2是保留函数依赖分解<br>
但是如果R拆分为R1(A,B)和R3(A,C)，其中B-&gt;C的关系未说明，那么这种拆分不是保持函数分解</p>
</li>
<li>
<p>无损分解<br>
<strong><mark>无损表示可以还原的分解方法</mark></strong></p>
<pre class="hljs"><code><div>例：有关系模式：成绩（学号，姓名，课程号，课程名，分数）
函数依赖：学号-&gt;姓名，课程号-&gt;课程名，（学号，课程号）-&gt;分数
若将其分解为：
  成绩（学号，课程号，分数）
  学生（学号，姓名）
  课程（课程号，课程名）
这种方式是否是无损分解？
</div></code></pre>
<p><strong><code>方法一（还原法）：</code></strong></p>
<pre class="hljs"><code><div>解：这是一种无损分解
因为通过学生（学号，姓名）可以与成绩（学号，可称号，分数）做连接
通过课程（课程号，课程名）可以与成绩（学号，课程号，分数）做连接
</div></code></pre>
<p><strong><code>方法二（画表法）：</code></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">学号</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">课程号</th>
<th style="text-align:center">课程名</th>
<th style="text-align:center">分数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">成绩</td>
<td style="text-align:center"><code>a1</code></td>
<td style="text-align:center">b12</td>
<td style="text-align:center"><code>a3</code></td>
<td style="text-align:center">b14</td>
<td style="text-align:center"><code>a5</code></td>
</tr>
<tr>
<td style="text-align:center">学生</td>
<td style="text-align:center"><code>a1</code></td>
<td style="text-align:center"><code>a2</code></td>
<td style="text-align:center">b23</td>
<td style="text-align:center">b23</td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">课程</td>
<td style="text-align:center">b31</td>
<td style="text-align:center">b32</td>
<td style="text-align:center"><code>a3</code></td>
<td style="text-align:center"><code>a4</code></td>
<td style="text-align:center">b35</td>
</tr>
</tbody>
</table>
<p>其中横排的是原表，包含学号、姓名、课程号、课程名和分数<br>
左栏是拆分的表名称：成绩、学生和课程
用an表示拆分表中有该参数，n表示第n列，那么成绩行，学号列是a1，其余用bmn（表示第m行，第n列）表示<br>
如果某一行中a1，a2有关系，另一行只有a1，那么这一行a1和a2皆为已知，例如上表可以修改为：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">学号</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">课程号</th>
<th style="text-align:center">课程名</th>
<th style="text-align:center">分数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">成绩</td>
<td style="text-align:center"><code>a1</code></td>
<td style="text-align:center"><strong><code>a2</code></strong></td>
<td style="text-align:center"><code>a3</code></td>
<td style="text-align:center">b14</td>
<td style="text-align:center"><code>a5</code></td>
</tr>
<tr>
<td style="text-align:center">学生</td>
<td style="text-align:center"><code>a1</code></td>
<td style="text-align:center"><code>a2</code></td>
<td style="text-align:center">b23</td>
<td style="text-align:center">b23</td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">课程</td>
<td style="text-align:center">b31</td>
<td style="text-align:center">b32</td>
<td style="text-align:center"><code>a3</code></td>
<td style="text-align:center"><code>a4</code></td>
<td style="text-align:center">b35</td>
</tr>
</tbody>
</table>
<p>注意上述第2行第2列值修改为已知值<br>
以此类推，这个表可以逐步修改为：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">学号</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">课程号</th>
<th style="text-align:center">课程名</th>
<th style="text-align:center">分数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">成绩</td>
<td style="text-align:center"><code>a1</code></td>
<td style="text-align:center"><strong><code>a2</code></strong></td>
<td style="text-align:center"><code>a3</code></td>
<td style="text-align:center"><strong><code>b4</code></strong></td>
<td style="text-align:center"><code>a5</code></td>
</tr>
<tr>
<td style="text-align:center">学生</td>
<td style="text-align:center"><code>a1</code></td>
<td style="text-align:center"><code>a2</code></td>
<td style="text-align:center">b23</td>
<td style="text-align:center">b23</td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">课程</td>
<td style="text-align:center">b31</td>
<td style="text-align:center">b32</td>
<td style="text-align:center"><code>a3</code></td>
<td style="text-align:center"><code>a4</code></td>
<td style="text-align:center">b35</td>
</tr>
</tbody>
</table>
<p><strong><mark>其中有一行全都变成a，因此可以证明本次分解为无损分解</mark></strong><br>
<strong><code>方法三（公式法）：</code></strong><br>
<mark><strong><code>此方法仅限于一分二</code></strong></mark><br>
例如R分解为R1和R2，那么那么求解出：<br>
R1∩R2=A<br>
R1-R2=B<br>
R2-R1=C<br>
如果A-&gt;B或者A-&gt;C有一个成立那么就是无损分解</p>
<hr>
<p>注意下题另为一题：</p>
<pre class="hljs"><code><div>设R=ABC，F{A-&gt;B}，ρ1={R1(AB),R2(AC)}和ρ2={R1(AB),R3(BC)}是否是无损分解？
</div></code></pre>
<pre class="hljs"><code><div>解：1.
R1∩R2=A
R1-R2=B
R2-R1=C
A-&gt;B为题意，那么这是一个无损分解
2.
R1∩R2=B
R1-R2=A
R2-R1=C
B-&gt;A和B-&gt;C都没有出现
则这不是无损分解
</div></code></pre>
</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h2 id="%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6">并发控制</h2>
<ul>
<li>
<h3 id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</h3>
事务：保证操作只有全都做和全不做两种状态<br>
事务特性：原子性（不能拆分）、一致性（执行前和执行后的一致性）、隔离性（事务之前互不影响）、持续性（结果具有持续性）
<ul>
<li>并发的问题<br>
<mark><strong>1. 丢失更新</strong></mark><br>
<mark><strong>2. 不可重复读</strong></mark><br>
<mark><strong>3. 读“脏”数据</strong></mark>
<br><pre class="hljs"><code><div>例子：
1.丢失更新：
  T1        T2
①读取A=10
②          读A=10
③A=A-5写回
④          A=A-8写回
上述会导致A-8覆盖掉A-5，导致结果A=2

2.不可重复读
  T1       T2
①读A=20
  读B-30
  求和=50
②         读A=20
           A=A+50
           A=70
③演算出错

3.读“脏”数据
  T1       T2
①读A=20
  A=A+50
  写回70
②         读A=70
③ROLLBACK
  A恢复为20
A+50只是一个临时值
</div></code></pre>
</li>
</ul>
</li>
<li>
<h3 id="%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE">封锁协议</h3>
<ul>
<li>一级封锁协议<br>
<mark><strong>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放，<code>可以防止丢失修改</code></strong></mark></li>
<li>二级封锁协议<br>
<mark><strong>一级封锁协议加上事务T在读取数据R之前对其加S锁，<code>读完</code>后可释放S锁，<code>可以防止丢失修改，还可以防止读“脏”数据</code></strong></li>
<li>三级封锁协议<br>
<mark><strong>一级封锁协议加上事务T在读取数据R之前对其加S锁，<code>直到事务结束才释放</code>，<code>可防止丢失修改、防止防止丢失修改，还可以防止读“脏”数据</code></strong></mark></li>
<li>两段锁协议<br>
<mark><strong>可串行化的</strong></mark>，<mark><strong>可能发生死锁</strong></mark></li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h2 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F">数据库完整性约束</h2>
<ul>
<li>
<h3 id="%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F">实体完整性约束</h3>
<p>利用主键对输入内容的约束</p>
</li>
<li>
<h3 id="%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F">参照完整性约束</h3>
<p>利用外键对输入内容的参照</p>
</li>
<li>
<h3 id="%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F">用户自定义完整性约束</h3>
<p>对输入的内容值的规定范围</p>
<p>数据库完整性约束用于提高数据库中数据的可靠性和完整性</p>
</li>
<li>
<h3 id="%E8%A7%A6%E5%8F%91%E5%99%A8">触发器</h3>
<p>对于一些复杂的情况，需要利用触发器通过脚本的形式对数据库进行约束</p>
</li>
</ul>
<h2 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8">数据库安全</h2>
<table>
<tr>
  <td width="100px"><b>措施</b></td>
  <td><b>说明</b></td>
</tr>
<tr>
  <td>用户标识和鉴定</td>
  <td>最外层的安全保护措施，可以使用用户账户、口令及随机数检验等方式
</tr>
<tr>
  <td>存取控制</td>
  <td>对用户进行授权，包括操作类型（如查找、插入、删除、修改等动作）和数据对象（主要是数据范围）的权限
</tr>
<tr>
  <td>密码存储和传输</td>
  <td>对远程终端信息用密码传输</td>
</tr>
<tr>
  <td>视图的保护</td>
  <td>对视图进行授权</td>
</tr>
<tr>
  <td>审计</td>
  <td>使用一个专用文件或数据库，自动将用户对数据库的所有操作记录下来
</tr>
</table>
<h2 id="%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%87%E4%BB%BD">数据的备份</h2>
<ul>
<li>
<h3 id="%E7%83%AD%E5%A4%87%E4%BB%BD%E5%92%8C%E5%86%B7%E5%A4%87%E4%BB%BD">热备份和冷备份</h3>
<table>
<tr>
  <td width="70"><b>备份方式</b></td>
  <td width="200"><b>优点</b></td>
  <td width="200"><b>缺点</b></td>
</tr>
<tr>
  <td>冷备份</td>
  <td>非常快速的备份方法（需要备份文件），容易归档（简单复制即可），容易恢复到某个时间点上（只需要复制回去），能与归档方法结合，做数据库“最佳状态”的恢复；<mark><b>低度维护，高度安全</mark></b>
  <td>单独使用时，只能提供到某一时间点上的恢复；<mark><b>在实施备份的全过程中，数据库必须要做备份而不能做其他工作；</mark></b>若磁盘空间有限只能复制到磁盘等外部设备上，<mark><b>速度缓慢，不能按表或者用户恢复</mark></b>
</tr>
<tr>
  <td>热备份</td>
  <td>可在表空间或数据库文件级备份，备份的时间段；<mark><b>备份时数据库仍可以使用，可达到秒级恢复（恢复到某一时间点上）</mark></b>；可对几乎所有的数据库实体做恢复；恢复速度快速</td>
  <td>不能出错，否则后果很严重，若热备份不成功所得到的结果不可用于时间点的恢复；困难于维护，所以要特别小心，<mark><b>不允许失败</b></mark></td>
</tr>
</table>
</li>
<li>
<h3 id="%E5%AE%8C%E5%85%A8%E5%A4%87%E4%BB%BD%E5%B7%AE%E9%87%8F%E5%A4%87%E4%BB%BD%E5%92%8C%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD">完全备份、差量备份和增量备份</h3>
<ul>
<li>完全备份：<mark><strong>备份所有数据</strong></mark></li>
<li>差量备份：<mark><strong>仅备份上一次<code>完全备份</code>之后变化的数据</strong></mark></li>
<li>增量备份：<mark><strong>仅备份上一次<code>备份</code>之后变化的数据</strong></mark></li>
</ul>
</li>
<li>
<h3 id="%E5%90%84%E7%A7%8D%E8%BD%AC%E5%82%A8">各种转储</h3>
<p>海量一般表示全部存储，增量一般表示针对上一次的备份后备份变化的数据<br>
静态一般表示在系统中无运行事务时进行，动态一般表示每次只转储上次转储后更新的数据</p>
<ul>
<li>静态<code>海量</code>转储：<strong>在系统中无运行事务时进行，每次转储全部数据库</strong></li>
<li>静态<code>增量</code>转储：<strong>在系统中无运行事务时进行，每次只转储上次转储后更新的数据</strong></li>
<li>动态<code>海量</code>转储：<strong>转储期间允许对数据库进行存取或修改，每次转储全部数据库</strong></li>
<li>动态<code>增量</code>转储：<strong>转储期间允许对数据库进行存取或修改，每次只转储上次转储后更新的数据</strong></li>
</ul>
</li>
<li>
<h3 id="%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">日志文件</h3>
<p>日志文件是针对数据库改变所做的记录，它可以记录针对数据库的任何擦欧总，并将记录结果保存在独立的文件中</p>
</li>
<li>
<h3 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%85%E9%9A%9C%E4%B8%8E%E6%81%A2%E5%A4%8D">数据库的故障与恢复</h3>
<table>
<thead>
<tr>
<th style="text-align:center">故障关系</th>
<th style="text-align:center">故障原因</th>
<th style="text-align:center">解决方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">事务本身的可预期故障</td>
<td style="text-align:center">本身逻辑</td>
<td style="text-align:center">在程序中预先设置Rollback语句</td>
</tr>
<tr>
<td style="text-align:center">事务本身不可预期故障</td>
<td style="text-align:center">算数溢出、违反存储保护</td>
<td style="text-align:center">由于DBMS恢复通过日志，撤销事务对数据库的修改，回到事务最初状态</td>
</tr>
<tr>
<td style="text-align:center">系统故障</td>
<td style="text-align:center">系统停止运转</td>
<td style="text-align:center">通常使用检查点法</td>
</tr>
<tr>
<td style="text-align:center">介质故障</td>
<td style="text-align:center">外存被破坏</td>
<td style="text-align:center">一般使用日志重做业务</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98">数据仓库与数据挖掘</h2>
<ul>
<li>
<h3 id="%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93">数据仓库</h3>
<ul>
<li>
<p>数据仓库特点:<br>
1.面向主题<br>
2.数据仓库存储集成数据<br>
3.数据仓库一般不做修改，具有相对稳定性<br>
4.反应时间的变化</p>
</li>
<li>
<p>数据仓库的建立<br>
<img src="./p21.png" width = "600" height = "280"></p>
<p>备注：<br>
清理：对数据进行格式化
OLAP：联机分析处理器，用于分析处理</p>
</li>
</ul>
</li>
<li>
<h3 id="%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB">数据挖掘方法分类</h3>
--</li>
</ul>
<h2 id="%E5%8F%8D%E8%A7%84%E8%8C%83%E5%8C%96">反规范化</h2>
<p>规范化会使得表不断拆分，导致拆分的表过多，减少数据冗余但是会增加查询的工作量</p>
<ul>
<li>技术手段<br>
1.增加派生性冗余列<br>
2.增加冗余列<br>
3.重新组表<br>
4.分割表</li>
</ul>
<h2 id="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">大数据基本概念</h2>
<ul>
<li>
<p>用4V表示大数据的特点：<br>
1.Volume（数据量大）<br>
2.Velocity（速度快）<br>
3.Variety（多样性丰富）<br>
4.Value（价值大）</p>
</li>
<li>
<p>大数据的重要特征<br>
1.高度可扩展性<br>
2.高性能<br>
3.高度容错<br>
4.支持异构环境<br>
5.较短的分析延迟<br>
6.易用且开放的接口<br>
7.较低成本<br>
8.向下兼容性</p>
</li>
</ul>

</body>
</html>
