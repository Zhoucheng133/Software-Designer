<!DOCTYPE html>
<html>
<head>
<title>2.操作系统基本原理.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #ff0000; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">操作系统基本原理</h1>
<h2 id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0">操作系统概述</h2>
<ul>
<li>操作系统作用
<ul>
<li>管理系统硬件、软件和数据资源</li>
<li>控制程序运行</li>
<li>人机之间的借口</li>
<li>应用软件与硬件之间的接口</li>
</ul>
</li>
<li>操作系统的功能
<ul>
<li>进程管理
<ul>
<li>进程状态</li>
<li><mark><strong>前趋图</strong></mark></li>
<li><mark><strong>PV操作</strong></mark></li>
<li>死锁问题</li>
</ul>
</li>
<li>存储管理
<ul>
<li>段页式存储</li>
<li><mark><strong>页面置换算法</strong></mark></li>
</ul>
</li>
<li>文件管理
<ul>
<li>索引文件</li>
<li><mark><strong>位视图</strong></mark></li>
</ul>
</li>
<li>作业管理</li>
<li>设备管理</li>
</ul>
</li>
</ul>
<h2 id="%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">进程管理</h2>
<ul>
<li>
<h3 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81">进程的状态</h3>
<p><mark><strong>三态图：（三态模型）</strong></mark><br>
<mark><strong>新建和结束不包含在三态模型中</strong></mark></p>
<img src="./p5.png" width = "400" height = "208">
<p>备注：<br>
运行状态：进程所需的所有的资源都已经准备就绪，正在被CPU执行<br>
就绪状态：其他所有资源已经准备好，等待CPU执行<br>
等待（阻塞）状态：等待用户指令或者等待I/O设备做出反应等</p>
<p><strong>等待状态又叫做阻塞状态</strong></p>
<p>在三态图（三态模型）的基础上又可以人为增加挂起状态（静止就绪状态和静止阻塞状态<br>
原本的就绪状态和阻塞状态可以变为活跃就绪和活跃等待（阻塞）</p>
<p>由此可以得到下图</p>
<p><mark><strong>五态图（五态模型）：</strong></mark></p>
<img src="./p6.png" width = "300" height = "300">
</li>
<li>
<h3 id="%E5%89%8D%E8%B6%8B%E5%9B%BE">前趋图</h3>
<p>前趋图用来表示一系列活动的前后关系<br>
例如下图：<br>
<img src="./p7.png" width = "200" height = "200"></p>
<p>通过上图可以表现出那些任务可以并行，哪些需要有先后顺序</p>
<p>例如在上图中可以得到如果要完成E需要先完成D，而完成D又需要同时完成A、B、C</p>
</li>
<li>
<h3 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5">进程的同步与互斥</h3>
<ul>
<li>
<p>互斥<br>
在同一时刻只运行一个进程去使用这一个资源，一个资源无法被多个进程去使用</p>
<p>例如千军万马过独木桥就是互斥</p>
</li>
<li>
<p>同步<br>
速度有差异，在一定情况下需要停下等待</p>
<p>例如跑步比赛，先到的人需要停下等待后者到达</p>
</li>
</ul>
</li>
<li>
<h3 id="pv%E6%93%8D%E4%BD%9C">PV操作</h3>
<p>临界资源：进程之间需要以互斥方式对其进行共享的资源，例如打印机、磁带机等<br>
临界区：每个进程中访问临界资源的那段代码成为临界区
信号量：一种特殊的变量</p>
<p>P操作：等待（Wait）操作<br>
V操作：指示（signal）操作</p>
<ul>
<li>P操作
<ol>
<li>S=S-1</li>
<li>如果S<code>&lt;</code>0，则阻塞</li>
<li>如果S<code>≥</code>0，则继续执行当前指令</li>
</ol>
</li>
<li>S操作
<ol>
<li>S=S+1</li>
<li>如果S<code>≤</code>0，则阻塞</li>
<li>如果S<code>&gt;</code>0，则继续执行当前指令</li>
</ol>
</li>
</ul>
<pre class="hljs"><code><div>单缓冲区生产者-消费者问题：

s1=1,s2=0;
生产者:
  生产一个产品;
  P(s1);
  送产品到缓冲区;
  V(s2);

消费者:
  P(s2);
  从缓冲区拿产品;
  V(s1);
  消费产品;
</div></code></pre>
<pre class="hljs"><code><div>上述说明：
如果执行生产者：
P(s1) 将s1-1=0
V(s2) 将s2+1=1
此时如果再执行生产者操作，那么将s1-1=-1时候会阻塞生产者进程

如果执行消费者：
P(s2) 将s2-1=-1会阻塞消费者进程
</div></code></pre>
<hr>
<p><strong><code>注意下面的是另一题了</code></strong></p>
<pre class="hljs"><code><div>例：某书店有一个收银员，概述点最多允许n个购书者进入，将收银员和购书者看作不同的进程，其工作流程如下图所示。利用PV操作实现该过程，设置信号量S1、S2和Sn，初值分别为0，0，n，则图中a1和a2应该填入___，图中b1和b2应该填入___。
</div></code></pre>
<img src="./p8.png" width = "400" height = "400">
<pre class="hljs"><code><div>解：（这题答案不唯一，第二种答案以【】形式标记）
购买时需要告诉收银员开始收银，因此a1应该是V(S1)【V(S2)】
在收银进程中需要等待需要收银，因此b1应该是P(S1)【P(S2)】
在收银结束后需要返回购买完成，因此b2应该是V(S2)【V(S1)】
在购买者的进程中等待收银完成，因此a2应该是P(S2)【P(S1)】
</div></code></pre>
</li>
<li>
<h3 id="pv%E6%93%8D%E4%BD%9C%E5%92%8C%E5%89%8D%E8%B6%8B%E5%9B%BE">PV操作和前趋图</h3>
<p>例如在先前的前趋图中<br>
<img src="./p7.png" width = "200" height = "200"></p>
<p>可以使用PV操作来表示</p>
<pre class="hljs"><code><div>A-&gt;D:Sa
B-&gt;D:Sb
C-&gt;D:Sc
D-&gt;E:Sd

可以得到PV操作如下：

进程A:
V(Sa);

进程B:
V(Sb);

进程C
V(Sc);

进程D:
P(Sa);
P(Sb);
P(Sc);
V(Sd);

进程E:
P(Sd);
</div></code></pre>
<hr>
<p><strong><code>注意下面的是另一题了</code></strong></p>
<pre class="hljs"><code><div>进程P1、P2、P3、P4、P5的前趋图如下图所示，若用PV操作控制进程并发执行过程，则需要设置4个信号量S1、S2、S3和S4，且信号量的初值都为0，图中a和b应分别填写___，c和d应填写___，e和f应填写___。
</div></code></pre>
<img src="./p9.png" width = "450" height = "210">
<pre class="hljs"><code><div>解：
P1执行之后要执行V(signal)操作，即a为V(S1)
P2执行之后要执行V(signal)操作，即b为V(S2)
P3执行的条件是P1和P2都执行完成，即c为P(S1),P(S2)
P3执行之后要执行V(signal)操作，即d为V(S3),V(S4)
P4执行的条件是S3，即e为P(S3)
P5执行的条件是S4，即f为P(S4)
</div></code></pre>
</li>
<li>
<h3 id="%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98">死锁问题</h3>
<p>死锁就是系统中有一些资源和进程，但是系统发现所有进程都无法分分配到资源</p>
<p>死锁的四大条件</p>
<ol>
<li>互斥条件</li>
<li>保持和等待</li>
<li>不剥夺</li>
<li>环路等待</li>
</ol>
<p>打破死锁的方法</p>
<ol>
<li>死锁的预防
<ul>
<li>打破四大条件</li>
</ul>
</li>
<li>死锁的避免
<ul>
<li>有序资源分配法</li>
<li>银行家算法</li>
</ul>
</li>
</ol>
<hr>
</li>
<li>
<h3 id="%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">银行家算法</h3>
<pre class="hljs"><code><div>例：假设系统中有三类互斥资源R1、R2、R3，可用资源数分别为9、8、5，在T0时刻系统中有P1、P2、P3、P4和P5五个进程，这些进程对资源的最大需求量和已分配资源数如下图，安全序列为___
</div></code></pre>
<p><br><br></p>
<table>
<tr>
  <td>进程</td>
  <td colspan="3">最大需求量</td>
  <td> </td>
  <td colspan="3">已分配资源数</td>
  <td> </td>
  <td colspan="3">所需要资源数</td>
</tr>
<tr>
  <td></td>
  <td>R1</td>
  <td>R2</td>
  <td>R3</td>
  <td> </td>
  <td>R1</td>
  <td>R2</td>
  <td>R3</td>
  <td> </td>
  <td>R1</td>
  <td>R2</td>
  <td>R3</td>
<tr>
<tr>
  <td>P1</td>
  <td>6</td>
  <td>5</td>
  <td>2</td>
  <td></td>
  <td>1</td>
  <td>2</td>
  <td>1</td>
  <td></td>
  <td>5</td>
  <td>3</td>
  <td>1</td>
</tr>
<tr>
  <td>P2</td>
  <td>2</td>
  <td>2</td>
  <td>1</td>
  <td></td>
  <td>2</td>
  <td>1</td>
  <td>1</td>
  <td></td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
</tr>
<tr>
  <td>P3</td>
  <td>8</td>
  <td>1</td>
  <td>1</td>
  <td></td>
  <td>2</td>
  <td>1</td>
  <td>0</td>
  <td></td>
  <td>6</td>
  <td>0</td>
  <td>1</td>
</tr>
<tr>
  <td>P4</td>
  <td>1</td>
  <td>2</td>
  <td>1</td>
  <td></td>
  <td>1</td>
  <td>2</td>
  <td>0</td>
  <td></td>
  <td>0</td>
  <td>0</td>
  <td>1</td>
</tr>
<tr>
  <td>P5</td>
  <td>3</td>
  <td>4</td>
  <td>4</td>
  <td></td>
  <td>1</td>
  <td>1</td>
  <td>3</td>
  <td></td>
  <td>2</td>
  <td>3</td>
  <td>1</td>
</tr>
</table>
<pre class="hljs"><code><div>解：目前可得系统可用资源是（2，1，0）
那么从所需要的资源数来看只有P2可以执行
经过执行P2，系统可用（4，2，1），之后只有P4可以执行
经过执行P4，系统可用（5，4，1），之后P5和P1都可以执行
……（剩下略）
</div></code></pre>
</li>
</ul>
<h2 id="%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86">存储管理</h2>
<ul>
<li>
<h3 id="%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87">分区存储组织</h3>
<mark><strong>不同的分配方法:</strong></mark>
<ul>
<li>首次适应法<br>
<mark><strong>每次都从开始，找到可以存放得下的空间就存下</strong></mark><table>
<tr>
  <td>分配前</td>
  <td></td>
  <td>分配后</td>
</tr>
<tr>
  <td>作业1(33k)</td>
  <td></td>
  <td>作业1(33k)</td>
</tr>
<tr>
  <td rowspan="2">25k</td>
  <td></td>
  <td>作业4(9k)</td>
</tr>
<tr>
  <td></td>
  <td>16k</td>
</tr>
<tr>
  <td>作业2(22k)</td>
  <td></td>
  <td>作业2(22k)</td>
</tr>
  <tr>
  <td>作业3(10k)</td>
  <td></td>
  <td>作业3(10k)</td>
</tr>
  <tr>
  <td>28k</td>
  <td></td>
  <td>28k</td>
</tr>
<tr>
  <td>10k</td>
  <td></td>
  <td>10k</td>
</tr>
</table>
</li>
<li>最佳适应法<br>
<mark><strong>寻找到最适合的（即大小的≥需要空间的最小空间）</strong></mark><br>
<mark><strong>系统会自动组成一个空间从小到大的链表</strong>  </mark><table>
<tr>
  <td>分配前</td>
  <td></td>
  <td>分配后</td>
</tr>
<tr>
  <td>作业1(33k)</td>
  <td></td>
  <td>作业1(33k)</td>
</tr>
<tr>
  <td>25k</td>
  <td></td>
  <td>25k</td>
</tr>
<tr>
  <td>作业2(22k)</td>
  <td></td>
  <td>作业2(22k)</td>
</tr>
  <tr>
  <td>作业3(10k)</td>
  <td></td>
  <td>作业3(10k)</td>
</tr>
<tr>
  <td>28k</td>
  <td></td>
  <td>28k</td>
</tr>
<tr>
  <td rowspan="2">10k</td>
  <td></td>
  <td>作业4(9k)</td>
</tr>
<tr>
  <td></td>
  <td>1k</td>
</tr>
</table>
</li>
<li>最差适应法<br>
<mark><strong>寻找到空间最大的存放</strong></mark><br>
<mark><strong>注意每次重新计算最大空间</strong></mark> <table>
<tr>
  <td>分配前</td>
  <td></td>
  <td>分配后</td>
</tr>
<tr>
  <td>作业1(33k)</td>
  <td></td>
  <td>作业1(33k)</td>
</tr>
<tr>
  <td>25k</td>
  <td></td>
  <td>25k</td>
</tr>
<tr>
  <td>作业2(22k)</td>
  <td></td>
  <td>作业2(22k)</td>
</tr>
  <tr>
  <td>作业3(10k)</td>
  <td></td>
  <td>作业3(10k)</td>
</tr>
<tr>
  <td rowspan="2">28k</td>
  <td></td>
  <td>作业4(9k)</td>
</tr>
<tr>
  <td></td>
  <td>19k</td>
</tr>
<tr>
  <td>10k</td>
  <td></td>
  <td>10k</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
<p><br><br></p>
<ul>
<li>
<p>循环首次适应<br>
<mark><strong>从上次查找到的空间开始搜寻，寻找下一个能存放的空间</strong></mark></p>
<table>
<tr>
  <td>分配前</td>
  <td></td>
  <td>分配后</td>
</tr>
<tr>
  <td>作业1(33k)</td>
  <td></td>
  <td>作业1(33k)</td>
</tr>
<tr>
  <td>25k</td>
  <td></td>
  <td>25k</td>
</tr>
<tr>
  <td>作业2(22k)</td>
  <td></td>
  <td>作业2(22k)</td>
</tr>
  <tr>
  <td>作业3(10k)</td>
  <td></td>
  <td>作业3(10k)</td>
</tr>
<tr>
  <td rowspan="2">28k</td>
  <td></td>
  <td>作业4(9k)</td>
</tr>
<tr>
  <td></td>
  <td>19k</td>
</tr>
<tr>
  <td>10k</td>
  <td></td>
  <td>10k</td>
</tr>
</table>
</li>
<li>
<h3 id="%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8">页式存储/段式存储/段页式存储</h3>
<ul>
<li>
<p>页式存储</p>
<table>
<tr>
  <td align="center"><b>用户程序</b></td>
  <td align="center"><b>  </b></td>
  <td align="center" colspan="2"><b>页表</b></td>
</tr>
<tr>
  <td align="center"></td>
  <td align="center"><b>  </b></td>
  <td align="center"><b>页号</b></td>
  <td align="center"><b>块号(又叫做页帧号)</b></td>
</tr>
<tr>
  <td align="center">0页</td>
  <td align="center"><b>  </b></td>
  <td align="center">0</td>
  <td align="center">1</td>
</tr>
<tr>
  <td align="center">1页</td>
  <td align="center"><b>  </b></td>
  <td align="center">1</td>
  <td align="center">3</td>
</tr>
<tr>
  <td align="center">2页</td>
  <td align="center"><b>  </b></td>
  <td align="center">2</td>
  <td align="center">6</td>
</tr>
<tr>
  <td align="center">……</td>
  <td align="center"><b>  </b></td>
  <td align="center" colspan="2">……</td>
</tr>
<tr>
  <td align="center">n页</td>
  <td align="center"><b>  </b></td>
  <td align="center" colspan="2">……</td>
</tr>
</table>
<p>不再将用户程序整个调到内存，需要运行的块（页）调入内存即可<br>
<mark><strong>存在内碎片，但是没有外碎片</strong></mark></p>
<p>优点：利用率高，碎片小，分配管理简单<br>
缺点：增加了系统开销（转换过程），可能发生抖动现象</p>
<p>通过逻辑地址转换成物理地址：<br>
逻辑地址的页内地址就是物理地址的页内地址
通过页表查找页号对应的块号地址就是物理地址</p>
<table>
<thead>
<tr>
<th style="text-align:center">页号</th>
<th style="text-align:center">页内地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>转换为</p>
<table>
<thead>
<tr>
<th style="text-align:center">块号</th>
<th style="text-align:center">页内地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre class="hljs"><code><div>例：进程P有6个页面，页号分别为0～5，页面大小为4K，页面变换表如下所示，表中状态位等于1和0分别表示页面在内存和不在内存。假设系统给进程P分配了4个存储块，进程P要访问的逻辑地址为十六进制5A29H，那么该地址经过变换后，其物理地址应为十六进制___；如果进程P要访问的页面4不在内存，那么应该淘汰页号为___的页面
</div></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">页号</th>
<th style="text-align:center">页帧号</th>
<th style="text-align:center">状态位</th>
<th style="text-align:center">访问位</th>
<th style="text-align:center">修改位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">——</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">——</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>解：
1.4K对应的二进制是2的12次方，换算成16进制就是3位，即5A29的后三位是页内地址，第一位是页号，为5，则在表中对应的页帧号为6，即物理地址应为十六进制6A29H
2.只有访问位是0的才能淘汰（没有被访问），因此淘汰页号为1
</div></code></pre>
</li>
<li>
<p>段式存储<br>
<mark><strong>段式存储的大小不一定一样，而页式存储每个页号的大小都相同</strong></mark></p>
<table>
<thead>
<tr>
<th style="text-align:center">段号</th>
<th style="text-align:center">段内地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>相比页式存储，需要多一个段长</p>
<table>
<thead>
<tr>
<th style="text-align:center">段号</th>
<th style="text-align:center">段长</th>
<th style="text-align:center">基址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1k</td>
<td style="text-align:center">6k</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">600</td>
<td style="text-align:center">4k</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">500</td>
<td style="text-align:center">8k</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">200</td>
<td style="text-align:center">9k</td>
</tr>
</tbody>
</table>
<p><mark><strong>存在外碎片，但是没有内碎片</strong></mark></p>
<p>优点：多道程序共享内存，各段程序修改互不影响
缺点：内存利用率低，内存碎片浪费大</p>
</li>
<li>
<p>段页式存储<br>
结合段式存储和页式存储
优点：空间浪费少，存储共享容易，存储保护也很容易，能动态连接
缺点：由于管理软件的增加，复杂性和开销页随之增大，需要的硬件以及占用的内容也有所增加，使得执行速度大大降低</p>
</li>
<li>
<p>快表<br>
快表（存放在Cache）是一块小容量的相联存储器（按内容存储），由高速缓存器组成，速度快，并且可以从硬件上保证按内容并行查找，通常用来存放访问频率最高的少数活动页面。<br>
<strong><mark>没有使用快表表示每读一次内存，需要现在内存上查表，因此需要有两次访问内存的操作</mark></strong></p>
</li>
</ul>
</li>
<li>
<h3 id="%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">页面置换算法</h3>
<p>常见的页面置换算法：最优算法(OPT)，随机算法(RAND)，先进先出算法(FIFO，<strong>可能会产生抖动</strong>)，最近最少使用(LRU)算法(<strong>不会产生抖动</strong>)</p>
<ul>
<li>抖动(缺页率)<br>
如果分配更多的资源，反而会出现替换频率上升的情况
<hr>
</li>
<li>最优算法<br>
淘汰掉后面最远出现或者永远不会出现的<br>
理论上的最优，但是实际上并不可能发生的算法，通常用于对比</li>
<li>随机算法<br>
随机的方式的替换算法</li>
<li>先进先出(FIFO)<br>
<mark><strong>哪个先进入内存，先替换哪个</strong></mark></li>
<li>最近最少使用(LRU)<br>
<strong>分配的资源越多，表现的性能越好(没有抖动)</strong><br>
<mark><strong>哪个距离上次使用间隔最长就替换掉哪个</strong></mark></li>
</ul>
<pre class="hljs"><code><div>例:1.先进先出（FIFO）
</div></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>4</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>5</code></td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>3</code></td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>4</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>2</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>2</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>3</code></td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">缺页</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>2.最近最少使用（LRU）
</div></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>4</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>5</code></td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center"><code>2</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>3</code></td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>4</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center"><strong>4</strong></td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>2</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>3</code></td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><strong>3</strong></td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>5</code></td>
</tr>
<tr>
<td style="text-align:center">缺页</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
</tbody>
</table>
<hr>
<p><strong><code>注意下面是另外一题了</code></strong></p>
<pre class="hljs"><code><div>例：在一台按字节编址的8位计算机系统中，采用虚拟页式存储管理方案，页面的大小为1KB，且系统中没有使用快表，图所示的是划分6个页面的用户程序
图中swap A, B是16为的指令，A和B表示该指令的两个16位操作数，swap指令存放在1023单元中，操作数A存放在内存的3071单元中，操作数B存放在内存5119单元中，执行swap指令需要访问____次内存，将产生___次缺页中断。
</div></code></pre>
  <table width="300">
  <tr>
    <td  align="center"><b>页号</b></td>
    <td  align="center"><b>用户程序</b></td>
  </tr>
  <tr>
    <td  align="center">0</td>
    <td rowspan="2"  align="center">Swap A, B</td>
  </tr>
  <tr>
    <td  align="center">1</td>
  </tr>
  <tr>
    <td  align="center">2</td>
    <td rowspan="2" align="center">A</td>
  </tr>
  <tr>
    <td  align="center">3</td>
  </tr>
  <tr>
    <td  align="center">4</td>
    <td rowspan="2" align="center">B</td>
  </tr>
  <tr>
    <td  align="center">5</td>
  </tr>
  </table>
<p><mark><strong>指令只会产生一次缺页中断，但是操作数</strong></mark></p>
<pre class="hljs"><code><div>解：1.(没有使用快表表示每读一次内存，需要现在内存上查表)
没有使用快表，那么一次操作需要的流程为：
查询页表-&gt;查询页块（即需要两次访问内存）
图示中页号有6个单元，那么需要访问6 x 2 = 12 次访问
2.指令只会产生一次缺页中断，但是操作数（例如图中的AB）只会产生一次缺页中断，因此产生了5次缺页中断
</div></code></pre>
</li>
</ul>
<h2 id="%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</h2>
<ul>
<li>
<h3 id="%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">索引文件结构</h3>
<p>通常一共有13个索引节点，<strong>如果不是13个节点在考试中会有说明</strong><br>
其中：<br>
<mark><strong>0～9(10个)：直接索引（直接存放索引文件的内容），直接对应物理盘块</strong><br>
<strong>10号节点(第11个)：一级间接索引，存放索引文件的地址</strong><br>
<strong>11号节点(第12个)：二级间接索引，存放地址，这些地址指向的又是索引文件的地址</strong><br>
<strong>12号节点(第13个）：以此类推</strong><br>
<strong>越往后的索引运行效率越低</strong></mark><br>
<img src="./p10.png" width = "400" height = "270"></p>
<pre class="hljs"><code><div>例：假设文件系统采用索引节点管理，且索引节点有8个地址项iaddr[0]~iaddr[7]，每个地址项大小为4字节，iaddr[0]~iaddr[4]采用直接地址索引，iaddr[5]和iaddr[6]采用一级间接地址索引，iaddr[7]采用二级间接地址索引。假设磁盘索引块和磁盘数据块大小均为1KB字节，文件File1的索引节点如下图所示，若用户访问文件File1中逻辑块号为5和261的信息，则对应的物理块号分别为___，101号物理块存放的是___
</div></code></pre>
<img src="./p11.png" width = "300" height = "320">
<pre class="hljs"><code><div>解：
1.逻辑块号通常从0开始（如图所示）
由题得，一个地址项大小为4字节，那么iaddr[5]对应有1KB/4=256个逻辑地址，那么逻辑地址如图
那么第261个逻辑地址正好是187物理块号，5对应的是58物理块号
2.二级间接地址索引
</div></code></pre>
</li>
<li>
<h3 id="%E6%96%87%E4%BB%B6%E5%92%8C%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">文件和树形目录结构</h3>
<ul>
<li>
<p>文件属性<br>
R：只读文件
A：存档属性
S：系统文件
H：隐藏文件</p>
</li>
<li>
<p>树形目录结构
<mark><strong>绝对路径：从盘符开始的路径</strong><br>
<strong>相对路径：从当前路径开始的路径</strong></mark></p>
<pre class="hljs"><code><div>例如下图的树状文件路径图
</div></code></pre>
<img src="./p12.png" width = "300" height = "170">
<pre class="hljs"><code><div>那么f1的绝对路径就是/D1/W1/f1
如果当前目录为D1，那么f1的相对路径为W1/f1
</div></code></pre>
</li>
</ul>
</li>
<li>
<h3 id="%E7%A9%BA%E9%97%B2%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86">空闲存储空间的管理</h3>
<p>空闲存储空间管理的四个方法：空闲区表法（空闲文件目录）、空闲链表法（空闲区链表）、<mark><strong>位视图法</strong></mark>、成组链接法</p>
<ul>
<li>位视图法<br>
例如如下的位视图:
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<hr>
其中1表示被占，0表示没有被占<pre class="hljs"><code><div>例：某文件管理系统在磁盘上建立了位视图，记录磁盘的使用情况。若磁盘上的物理块依次编号为：0、1、2、……，系统中字长为32位，每一位对应文件存储器上的一个物理块，取值为0和1分别表示空闲和占用，如下图所示
假设将4195号物理块分配给某文件，那么该物理块的使用情况在位视图中的第___个字中描述，系统应该将该字的位置第___位置___
</div></code></pre>
<mark><strong>注意各种地址从0开始，物理块编号从0开始，并且第一个字为0，所以注意计算</strong></mark><pre class="hljs"><code><div>解：1.4195号物理块对应的是第4196个物理块
4196/32=131.125，即应该在第131字节中描述，是第132个字节
2.第131个位置为131 x 32 = 4192（0～4191）
即在第132字节中
第1位是4192，那么第5位是4195
</div></code></pre>
<br><br></li>
</ul>
</li>
</ul>
<h2 id="%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86">设备管理</h2>
<ul>
<li>
<h3 id="%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">数据传输控制方式</h3>
数据传输的几种方式：<mark><strong>程序控制方式（程序查询方式）、程序中断方式、DMA方式</strong></mark>、通道、输入输出处理机
<ul>
<li>
<p>程序控制（程序查询）方式<br>
<mark><strong>外设无法告诉CPU完成情况，需要CPU自行查询是否传输完毕</strong></mark></p>
<p><mark><strong>CPU会反复查询，效率低下</strong></mark></p>
</li>
<li>
<p>程序中断方式<br>
<mark><strong>如果外设完成（或者开始）传输，会向CPU发送中断请求，效率比程序控制（查询）方式高很多</strong></mark></p>
</li>
<li>
<p>DMA方式<br>
<strong>又叫做直接存取控制方式</strong></p>
<p><mark><strong>有专门的DMA控制器负责内存和外设的数据交换，CPU只需要在开始的时候进行一定程度的介入即可，效率又比程序查询高很多</strong></mark></p>
</li>
</ul>
</li>
<li>
<h3 id="%E8%99%9A%E8%AE%BE%E5%A4%87%E5%92%8Cspooling%E6%8A%80%E6%9C%AF">虚设备和Spooling技术</h3>
Spooling技术即<mark><strong>在多个设备对单个输入输出设备的情况，通过缓冲区将需要输入或者输出的内容缓存起来，解决外设低速的瓶颈问题</strong></mark>，按照队列依次输出或者输入</li>
</ul>
<h2 id="%E5%BE%AE%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF">微内核技术</h2>
<table>
<tr>
  <td width="55"></td>
  <td width="160"><b>实质</b></td>
  <td width="160"><b>优点</b></td>
  <td width="160"><b>缺点</b></td>
</tr>
<tr>
  <td>单体内核</td>
  <td>将图形、设备驱动以及文件系统等功能都在内核中实现，运行在内核状态和同一地址空间</td>
  <td>减少进程之间的通信和状态切换带来的系统开销，获得较高的运行效率</td>
  <td>内核庞大，占用资源较多且不易剪裁<br>系统的稳定性和安全性不好</td>
</tr>
<tr>
  <td>微内核</td>
  <td>只实现基本功能，将图形系统、文件系统、设备驱动及通信功能放在内核之外</td>
  <td>内核精炼，便于剪裁和移植。<br>系统服务程序运行在用户地址空间，系统的可靠性、稳定性和安全性较高。<br>可用于分布系统</td>
  <td><b><mark>用户状态</mark></b>和<b><mark>内核状态</b></mark>需要频繁切换，从而导致系统效率不如单体内核</td>
</tr>
</table>
</body>
</html>
