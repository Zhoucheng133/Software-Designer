<!DOCTYPE html>
<html>
<head>
<title>1.计算机组成与体系结构.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机组成与体系结构</h1>
<h2 id="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA">数据的表示</h2>
<ul>
<li>
<h3 id="%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</h3>
<ul>
<li>
<p>其他进制转换成十进制（<mark><strong>按权展开</strong></mark>）<br>
例如二进制10100.01=1x2<sup>4</sup>+1x2<sup>2</sup>+1x2<sup>-2</sup><br>
同理八进制、十六进制</p>
</li>
<li>
<p>十进制转换成其他进制（<mark><strong>短除法</strong></mark>）<br>
除以进制并且记录余数<br>
<strong>注意从下往上</strong></p>
</li>
<li>
<p>十进制转换八进制<br>
如果是10进制转换为8进制，则从右到左分段，每三个一段</p>
</li>
<li>
<p>十进制转十六进制<br>
如果是10进制转换为16进制，则从右到左分段，每四个一段</p>
</li>
</ul>
</li>
<li>
<h3 id="%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98">编码问题</h3>
<ul>
<li>
<p>原码<br>
最高位用于符号位，正数0，负数1</p>
</li>
<li>
<p>反码<br>
正数同原码一样<br>
负数的符号位不变，后面的所有位都取反</p>
</li>
<li>
<p>补码<br>
正数同原码一样<br>
负数在反码的基础上+1</p>
</li>
<li>
<p>移码<br>
补码的基础上首位（符号位）取反</p>
</li>
</ul>
</li>
<li>
<h3 id="%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4">编码表示范围</h3>
<p>原码：-(2<sup>n-1</sup>-1)~2<sup>n-1</sup>-1<br>
反码：-(2<sup>n-1</sup>-1)~2<sup>n-1</sup>-1<br>
补码：-2<sup>n-1</sup>~2<sup>n-1</sup>-1<br>
<mark><strong>原码和反码有+0和-0分区分，而补码没有</strong></mark></p>
</li>
<li>
<h3 id="%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97">浮点数运算</h3>
<p><mark><strong>通常表示为N=MxR<sup>e</sup></strong></mark><br>
<mark><strong>其中R为进制，M为尾数，e为阶码）</strong></mark></p>
<ul>
<li><strong>步骤:</strong><br>
<mark><strong>1. 对阶</strong></mark><br>
<mark><strong>2. 位数计算</strong></mark><br>
<mark><strong>3. 结构格式化</strong></mark></li>
</ul>
<p>注意对阶应该对大的部分对阶，例如1x10<sup>3</sup>和1.19x10<sup>2</sup>，应该化为0.119x10<sup>3</sup>和1x10<sup>3</sup></p>
</li>
</ul>
<h2 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84">计算机结构</h2>
<p>主机基本组成：</p>
<ul>
<li>CPU
<ul>
<li>运算器
<ul>
<li>算数逻辑单元(ALU)</li>
<li>累加寄存器(AC)</li>
<li>数据缓冲寄存器(DR)</li>
<li>状态条件寄存器(PSW)</li>
</ul>
</li>
<li>控制器
<ul>
<li>程序计数器(PC)</li>
<li>指令寄存器(IR)</li>
<li>指令译码器</li>
<li>时序部件</li>
</ul>
</li>
</ul>
</li>
<li>主存储器</li>
</ul>
<h2 id="flynn%E5%88%86%E7%B1%BB%E6%B3%95">Flynn分类法</h2>
<table>
<thead>
<tr>
<th style="text-align:center">体系结构类型</th>
<th style="text-align:center">控制部分</th>
<th style="text-align:center">关键特性</th>
<th style="text-align:center">代表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单指令流数据流(SISD)</td>
<td style="text-align:center">控制部分:一个<br>处理器：一个<br>主存模块:一个</td>
<td style="text-align:center">——</td>
<td style="text-align:center">单处理器系统</td>
</tr>
<tr>
<td style="text-align:center">单指令流多数据流(SIMD)</td>
<td style="text-align:center">控制部分:一个<br>处理器：多个<br>主存模块:多个</td>
<td style="text-align:center">各个处理器以异步<br>的形式执行同一条指令</td>
<td style="text-align:center">并行处理机<br><strong>阵列处理机</strong><br>超级向量处理机</td>
</tr>
<tr>
<td style="text-align:center">多指令流单数据流(MISD)</td>
<td style="text-align:center">控制部分:多个<br>处理器：一个<br>主存模块:多个</td>
<td style="text-align:center">被证明不可能</td>
<td style="text-align:center">目前没有</td>
</tr>
<tr>
<td style="text-align:center">多指令多数据流(MIMD)</td>
<td style="text-align:center">控制部分:多个<br>处理器：多个<br>主存模块:多个</td>
<td style="text-align:center">能实现作业、任务、<br>指令等各级全面并行</td>
<td style="text-align:center">多处理机系统<br>多计算机</td>
</tr>
</tbody>
</table>
<p><mark><strong>注意代表的类型(重点)</strong></mark><br>
<mark><strong>注意多个核心处理器的电脑不属于单指令流单数据流，属于单指令流多数据流</strong></mark>
<br><br><br><br><br><br></p>
<h2 id="cisc%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8Crisc%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86">CISC（复杂指令集）和RISC（精简指令集）</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令集</th>
<th style="text-align:center">指令</th>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">实现方式</th>
<th style="text-align:center">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CISC</td>
<td style="text-align:center">数量多，使用频率<br>差别大，可变长格式</td>
<td style="text-align:center">支持多种</td>
<td style="text-align:center">微程序控制技术<br>（微码）</td>
<td style="text-align:center">研制周期长</td>
</tr>
<tr>
<td style="text-align:center">RISC</td>
<td style="text-align:center">数量少，使用频率<br>接近，定长格式，大<br>部分为单周期指令，<br>操作寄存器，只有<br>Load/Store操作内存</td>
<td style="text-align:center">支持方式少</td>
<td style="text-align:center">增加了通用寄存器，<br>硬布线逻辑控制为主，<br>适合采用流水线</td>
<td style="text-align:center">优化编译，有<br>效支持高级语言</td>
</tr>
</tbody>
</table>
<p><strong>目前绝大多数的计算机都使用CISC（复杂指令集）而移动设备，尤其是手机，Pad基本上都是用RISC（精简指令集）</strong></p>
<h2 id="%E6%B5%81%E6%B0%B4%E7%BA%BF">流水线</h2>
<ul>
<li>
<h3 id="%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%A6%82%E5%BF%B5">流水线的概念</h3>
<p><strong>流水线的通常流程:取值、分析、执行</strong></p>
<table>
<tr>
    <td>取值</td>
    <td>1</td>
    <td></td>
    <td></td>
    <td>2</td>
    <td> </td>
    <td> </td>
    <td>3</td>
    <td> </td>
    <td> </td>
</tr>
<tr>
    <td>分析</td>
    <td> </td>
    <td>1</td>
    <td> </td>
    <td> </td>
    <td>2</td>
    <td> </td>
    <td> </td>
    <td>3</td>
    <td> </td>
</tr>
<tr>
    <td>执行</td>
    <td> </td>
    <td></td>
    <td>1</td>
    <td> </td>
    <td></td>
    <td>2</td>
    <td> </td>
    <td></td>
    <td>3</td>
</tr>
</table>
（上图）没有使用流水线执行指令情况
<table>
<tr>
    <td>取值</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td></td>
    <td> </td>
    <td> </td>
    <td></td>
    <td> </td>
    <td> </td>
</tr>
<tr>
    <td>分析</td>
    <td> </td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td></td>
    <td> </td>
    <td> </td>
    <td></td>
    <td> </td>
</tr>
<tr>
    <td>执行</td>
    <td> </td>
    <td></td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td></td>
    <td> </td>
    <td></td>
    <td></td>
</tr>
</table>
（上图）使用流水线执行指令情况
</li>
<li>
<h3 id="%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97">流水线的时间计算</h3>
<ul>
<li>
<p>流水线周期<br>
<mark><strong>流水线周期指的是执行时间最长的一段，步骤中最耗时的流程</strong></mark></p>
</li>
<li>
<p>流水线计算公式<br>
<mark><strong>一条指令执行时间+(执行条数-1)x流水线周期</strong></mark><br>
1. <mark><strong>理论公式：(t<sub>1</sub>+t<sub>2</sub>+…+t<sub>n</sub>)+(n-1)x△t</strong></mark><br>
2. <mark><strong>实践：(k+n-1)x△t</strong></mark></p>
<p>备注：△t为一个流水线周期时间
<br><br><br><br></p>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>例题：若指令流水线把一条指令氛围取值、分析和执行三个部分，且三个部分的时间分别为取值：2ns，分析2ns，执行1ns，那么流水线周期是多少？100条指令全部执行完毕需要时间是多少？
</div></code></pre>
<table>
<tr>
    <td>取值</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>…</td>
    <td>n</td>
    <td> </td>
    <td></td>
    <td> </td>
    <td> </td>
</tr>
<tr>
    <td>分析</td>
    <td> </td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>…</td>
    <td>n</td>
    <td> </td>
    <td></td>
    <td> </td>
</tr>
<tr>
    <td>执行</td>
    <td> </td>
    <td></td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>…</td>
    <td>n</td>
    <td></td>
    <td></td>
</tr>
</table>
<p><strong>根据图表可得，1:2只有取值，因此需要1ns2:3和3:4需要照应到1的取分析和执行过程，因此需要2ns</strong></p>
<pre class="hljs"><code><div>解：
1.流水线周期是 2 ns
2.(2+2+1)+99x2=203 ns
</div></code></pre>
<ul>
<li>
<h3 id="%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%90%9E%E5%90%90%E7%8E%87%E8%AE%A1%E7%AE%97">流水线的吞吐率计算</h3>
<ul>
<li>
<p><mark><strong>流水线的吞吐率(TP)=指令条数/流水线执行时间</strong></mark></p>
<p>以上述例题为例，则TP=100/203</p>
</li>
<li>
<p><mark><strong>流水最大吞吐率=1/△t</strong></mark></p>
</li>
</ul>
</li>
<li>
<h3 id="%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8A%A0%E9%80%9F%E6%AF%94%E8%AE%A1%E7%AE%97">流水线加速比计算</h3>
<ul>
<li>
<p><mark><strong>流水线加速比S=不使用流水线执行时间/使用流水线执行时间</strong></mark></p>
<p>以上述例题为例，如果不使用流水线，则执行时间为500，则S=500/203</p>
</li>
</ul>
</li>
<li>
<h3 id="%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%95%88%E7%8E%87">流水线的效率</h3>
<p>流水线的效率是指流水下设备利用率，在时空图上，流水线的效率定义为n个任务占用的时空去与k个流水段总的时空去之比</p>
<p><mark><strong>即流水线中所占用的时空÷所有时空</strong></mark></p>
<p>例如这样的任务流程:<br>
周期取最大值3△t：</p>
<table>
<tr>
  <td>s1</td>
  <td>s2</td>
  <td>s3</td>
  <td>s4</td>
</tr>
<tr>
  <td>△t</td>
  <td>△t</td>
  <td>△t</td>
  <td>3△t</td>
</tr>
</table>
则将这样的任务用时空图表示为：
<table>
<tr>
  <td>s1</td>
  <td>1</td>
  <td></td>
  <td></td>
  <td>2</td>
  <td></td>
  <td></td>
  <td>3</td>
  <td></td>
  <td></td>
  <td>4</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>s2</td>
  <td></td>
  <td>1</td>
  <td></td>
  <td></td>
  <td>2</td>
  <td></td>
  <td></td>
  <td>3</td>
  <td></td>
  <td></td>
  <td>4</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>s3</td>
  <td></td>
  <td></td>
  <td>1</td>
  <td></td>
  <td></td>
  <td>2</td>
  <td></td>
  <td></td>
  <td>3</td>
  <td></td>
  <td></td>
  <td>4</td>
  <td></td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>s4</td>
  <td></td>
  <td></td>
  <td></td>
  <td>1</td>
  <td>1</td>
  <td>1</td>
  <td>2</td>
  <td>2</td>
  <td>2</td>
  <td>3</td>
  <td>3</td>
  <td>3</td>
  <td>4</td>
  <td>4</td>
  <td>4</td>
</tr>
</table>
<ul>
<li><mark><strong>计算流水线效率公式为E=n个任务占用的时空区/k个流水段的时空区</strong></mark></li>
</ul>
<p>例如上述内容占用的时空区为(△t + △t + △t + 3△t) x 4=24△t<br>
总共有15△t x 4 = 60△t<br>
则流水线效率为24△t / 60△t = 2/5</p>
</li>
</ul>
<h2 id="%E5%B1%82%E6%AC%A1%E5%8C%96%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">层次化存储结构</h2>
<table>
<tr>
  <td>很快</td>
  <td>CPU(的寄存器)</td>
  <td></td>
  <td>容量很小</td>
</tr>
<tr>
  <td>快</td>
  <td>Cache(缓存)</td>
  <td>按内容存取</td>
  <td>容量小</td>
  <td>KB或者MB为单位</td>
</tr>
<tr>
  <td>慢</td>
  <td>主存(内存)</td>
  <td></td>
  <td>容量大</td>
  <td>以GB为单位</td>
</tr>
  <tr>
  <td>很慢</td>
  <td>辅存(外存)</td>
  <td>硬盘、光盘、U盘等</td>
  <td>容量很大</td>
  <td></td>
</tr>
</table>
<p><strong>注意：按内容存取的存储器又叫做相联存储器</strong></p>
<ul>
<li>
<h3 id="cache">Cache</h3>
<ul>
<li>
<p>Cache的概念</p>
<p>Cache工作于处理器和主存之间，<mark><strong>用于提高CPU输入输出的速率</strong></mark>，突破CPU与存储系统之间传送宽带限制。</p>
<p>在整个计算机存储体系中，除了CPU的寄存器，Cache的访问速度是最快的。</p>
<p>Cache改善系统性能的依据就是 <mark><strong>程序的局部性原理</strong></mark></p>
<p>如果以h代表Cache的访问命中率，t<sub>1</sub>表示Cache的周期时间，t<sub>2</sub>表示主存储器周期时间，以读操作为例，使用&quot;Cache+主存储器&quot;的系统的平均周期是t<sub>3</sub>，则：</p>
<p><mark><strong>t<sub>3</sub> = h x t<sub>1</sub> +(1-h) x t<sub>2</sub></strong></mark></p>
<p>其中(1-h)又称为失效率(未命中率)</p>
<pre class="hljs"><code><div>例题：假设Cache的命中率为95%，Cache周期是1ns，主存储器的周期是1ms（注：1ms=1000ns)，那么使用“Cache+主存储器“的系统平均周期是多少？
</div></code></pre>
<pre class="hljs"><code><div>解：t=95% x 1ns + (1-95%) x 1000ns
 上式=50.95ns
</div></code></pre>
</li>
<li>
<p>局部性原理</p>
<p>局部性原理分为 <mark><strong>时间局部性</strong></mark> 和 <mark><strong>空间局部性</strong></mark></p>
<p>时间局部性：刚刚访问结束的指令再次访问<br>
空间局部性：访问刚刚访问的邻近的地址</p>
<br>
</li>
</ul>
</li>
<li>
<h3 id="%E4%B8%BB%E5%AD%98">主存</h3>
<ul>
<li>
<p>主存的分类</p>
<table>
<tr>
  <td rowspan="2">随机存储器</td>
  <td>DRAM(动态RAM)</td>
</tr>
<tr>
  <td>SRAM(静态RAM)</td>
</tr>
<tr>
  <td rowspan="4">只读存储器</td>
  <td>MROM(掩模式ROM)</td>
</tr>
<tr>
  <td>PROM(一次性可编程ROM)</td>
</tr>
<tr>
  <td>EPROM(可擦除的PROM)</td>
</tr>
<tr>
  <td>Flash(闪存)</td>
</tr>
</table>
</li>
<li>
<p>主存的编址</p>
<p>8x4位的存储器如下图</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">000</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">010</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">011</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">101</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">110</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">111</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
</tr>
</tbody>
</table>
<p><strong>8个地址空间每个，每个地址空间存储了4bit空间</strong></p>
<p>使用两块这样的存储器可以组成8x8位存储器<br>
也可以组成16x4位的存储器</p>
<pre class="hljs"><code><div>例：内存地址从AC000H到C7FFFH，共有____K个地址单元，如果该内存地址按字(16bit)编址，由28片存储芯片构成。已知构成此内存的芯片每片由16K个存储单元，则该芯片每个存储单元存储___位
</div></code></pre>
<pre class="hljs"><code><div>解：
1.大的地址-小的地址，即
C7FFF-AC000+1=1C000=1C000
1C000的10进制为114688
114688÷1024=112 K
2.112K÷16K=7个
也就是至少需要7个就可以满足容量，总共用了28片
即(28÷7)*?=16 bit
可以得出每个芯片是4位
</div></code></pre>
</li>
</ul>
</li>
<li>
<h3 id="%E7%A3%81%E7%9B%98">磁盘</h3>
<ul>
<li>
<p>磁盘结构与参数</p>
<p>磁盘主要分为磁道、扇区和磁头<br>
<mark><strong>存取时间=寻道时间+等待时间(平均定位时间+转动延迟)</strong></mark></p>
</li>
<li>
<p>相关计算</p>
<pre class="hljs"><code><div>例：假设某磁盘的每个磁道划分为11个物理块，每块存放1个逻辑记录。逻辑记录R0,R1……R10存放在同一个磁道上，记录存放顺序如下表所示
</div></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">物理块</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">逻辑记录</td>
<td style="text-align:center">R0</td>
<td style="text-align:center">R1</td>
<td style="text-align:center">R2</td>
<td style="text-align:center">R3</td>
<td style="text-align:center">R4</td>
<td style="text-align:center">R5</td>
<td style="text-align:center">R6</td>
<td style="text-align:center">R7</td>
<td style="text-align:center">R8</td>
<td style="text-align:center">R9</td>
<td style="text-align:center">R10</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>如果磁盘旋转周期为33ms，当磁头当前处在R0的开始处，若系统使用单缓冲区顺序处理这些记录，每个记录处理时间为3ms，则处理这11个记录的最长时间为___；若对信息存储进行优化分布后，处理11个记录的最少时间为___。
</div></code></pre>
 <img src="./p1.png" width = "200" height = "190">
<pre class="hljs"><code><div>1.解：
转一圈周期是33ms，则每转到相邻的扇页区需要33÷11=3ms
转到R0末尾的时候开始处理R0的数据(3ms)，略过R1
因此如果需要处理完R1数据，就需要再转一圈(33ms)，总共需要36ms
针对R0，只需要6ms即可，但是对于R1~R10一共需要33x10ms
因此这一问答案为33x10+6=336ms
</div></code></pre>
<img src="./p2.png" width = "200" height = "200">
<pre class="hljs"><code><div>2.解：
如上图所示，可以依次读取R0，处理R0，读取R1，处理R1……
这样便不需要重新再转一圈读取和处理，没有时间浪费
这样只需要转2圈，66ms
</div></code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="%E6%80%BB%E7%BA%BF">总线</h2>
<ul>
<li>
<h3 id="%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB">总线分类</h3>
<ul>
<li>内部总线</li>
<li>系统总线
<ul>
<li>数据总线</li>
<li>地址总线(计算机系统的位数)</li>
<li>控制总线</li>
</ul>
</li>
<li>外部总线</li>
</ul>
</li>
</ul>
<h2 id="%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1">系统可靠性分析与设计</h2>
<ul>
<li>
<h3 id="%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F">串联系统和并联系统</h3>
<ul>
<li>
<p>串联<br>
串联模型中如果输入经由n个系统输出，其可靠性分别为R<sub>1</sub>、R<sub>2</sub>、R<sub>3</sub>……R<sub>n</sub><br>
那么系统的可靠性R为：<br>
<mark><strong>R=R<sub>1</sub> x R<sub>2</sub> x R<sub>3</sub> x …… R<sub>n</sub></strong></mark></p>
<p>失效率(<mark><strong>仅适用于少量</strong></mark>)为：<br>
<mark><strong>S=(1 - R<sub>1</sub>) + (1 - R<sub>2</sub>) + (1 - R<sub>3</sub>) + …… + (1 - R<sub>n</sub>)</strong></mark></p>
</li>
<li>
<p>并联<br>
并联系统中只有所有的系统失效才能失效<br>
因此如果在并联模型中输入经由n个系统输出，其可靠性分别为R<sub>1</sub>、R<sub>2</sub>、R<sub>3</sub>……R<sub>n</sub><br>
那么系统的可靠性R为：<br>
<mark><strong>R=1 - (1 - R<sub>1</sub>) x (1 - R<sub>2</sub>) x (1 - R<sub>3</sub> x …… x(1 - R<sub>n</sub>)</strong></mark></p>
<pre class="hljs"><code><div>由下图所示，求系统的可靠性
</div></code></pre>
<img src="./p4.png" width = "300" height = "150">
<pre class="hljs"><code><div>解:R x (1 - (1 - R)^3) x (1 - (1 - R)^2)
</div></code></pre>
</li>
<li>
<p>模冗余系统与混合系统<br>
<img src="./p3.png" width = "300" height = "150"><br>
R<sub>1</sub>～R<sub>m</sub>的作用相同，最终系统通过表决器来选择其中之一（通常少数服从多数，相当于屏蔽错误）</p>
<p>模冗余系统与混合系统几乎不考察</p>
</li>
</ul>
</li>
</ul>
<h2 id="%E6%A0%A1%E9%AA%8C%E7%A0%81">校验码</h2>
<ul>
<li>
<h3 id="%E7%A0%81%E8%B7%9D">码距</h3>
<p>通常通过增大码距的方式（增加冗余信息）来进行差错控制</p>
<p>码距就是指从A-&gt;B需要改变多少位</p>
<ol>
<li>例如1位长度的二进制编码，A=0，B=1，那么A和B之间的最小码距为1</li>
<li>例如2位长度的二进制编码，A=11，B=00，那么A和B之间的最小码距为2</li>
<li>例如3为长度的二进制编码，A=111，B=000，那么A和B之间的最小码距为3</li>
</ol>
<p>在上述的情况中，使用一位的二进制无法检查错误与否，使用两位二进制可以知道有错与否，但是无法知道其原本的内容，而使用三位二进制的编码，不仅可以知道错误与否，还可以知道其原本的编码</p>
</li>
<li>
<h3 id="%E5%BE%AA%E7%8E%AF%E6%A0%A1%E9%AA%8C%E7%A0%81crc">循环校验码(CRC)</h3>
<p><strong>循环校验码可以用于检查是否有错但是无法用于纠正错误</strong><br>
其原理是使用模二方法相除检测是否有余数</p>
<pre class="hljs"><code><div>例：原始报文为11001010101，其生成的多项式为：x^4+x^3+x+1。对其进行CRC编码后的结果为多少？
</div></code></pre>
</li>
</ul>
<br>
<pre class="hljs"><code><div>解：将生成的二项式转换为二进制形式
x^4+x^3+x+1
=&gt;11011
然后将原始报文后面加上这个二进制位数-1个0
也就是说将11001010101=&gt;110010101010000
      _________________
11011 )110010101010000
       11011
       ——————————
          10010
          11011
          ————————
           10000
           11011
           ————————
            10111
            11011
            ————————
             11000
             11011
             ————————
                11000
                11011
                ————————
                 0011
因此末尾的四个位为0011，则CRC编码后的结果为110010101010011

</div></code></pre>
<ul>
<li>
<h3 id="%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E7%A0%81">海明校验码</h3>
<mark><strong>公式2<sup>k</sup>-1≥n+k以确定k,n为原始数据,k即为校验位数</strong></mark><pre class="hljs"><code><div>例:求信息1011的海明码
</div></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">位数</th>
<th style="text-align:center">7</th>
<th style="text-align:center">6</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制</td>
<td style="text-align:center">111</td>
<td style="text-align:center">110</td>
<td style="text-align:center">101</td>
<td style="text-align:center">100</td>
<td style="text-align:center">011</td>
<td style="text-align:center">010</td>
<td style="text-align:center">001</td>
</tr>
<tr>
<td style="text-align:center">信息位</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">校验位</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">p2</td>
<td style="text-align:center"></td>
<td style="text-align:center">p1</td>
<td style="text-align:center">p0</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>解：1011一共4位，因此第一步求2^k-1≥4+k
求得k最小是3，因此需要3位校验位，设为p0,p1,p2
校验位分别为2^0、2^1和2^2位置上，即第一位，第二位和第四位上
p0 位是第一位，即001位，查找xx1的位置异或运算：
第3、5、7位异或（不同为1，相同为0）
p1 位是第二位，即010位，查找x1x的位置异或运算
第3、6、7位异或
p2 位是第四位，即100位，查找1xx的位置异或运算
第5、6、7位异或
</div></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">公式</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">p0</td>
<td style="text-align:center">1⊕1⊕1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">p1</td>
<td style="text-align:center">1⊕0⊕1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">p2</td>
<td style="text-align:center">1⊕0⊕1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>将结果填入表中，则最终得到：
1010101
即：
</div></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">位数</th>
<th style="text-align:center">7</th>
<th style="text-align:center">6</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制</td>
<td style="text-align:center">111</td>
<td style="text-align:center">110</td>
<td style="text-align:center">101</td>
<td style="text-align:center">100</td>
<td style="text-align:center">011</td>
<td style="text-align:center">010</td>
<td style="text-align:center">001</td>
</tr>
<tr>
<td style="text-align:center">结果</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong><code>0</code></strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong><code>0</code></strong></td>
<td style="text-align:center"><strong><code>1</code></strong></td>
</tr>
</tbody>
</table>
<hr>
<strong><code>注意下面的是另一题了</code></strong><pre class="hljs"><code><div>例:若收到的信息为1011101，那么是否有错，错在哪一位？
</div></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">位数</th>
<th style="text-align:center">7</th>
<th style="text-align:center">6</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制</td>
<td style="text-align:center">111</td>
<td style="text-align:center">110</td>
<td style="text-align:center">101</td>
<td style="text-align:center">100</td>
<td style="text-align:center">011</td>
<td style="text-align:center">010</td>
<td style="text-align:center">001</td>
</tr>
<tr>
<td style="text-align:center">结果</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><strong><code>1</code></strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong><code>0</code></strong></td>
<td style="text-align:center"><strong><code>1</code></strong></td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>解：一共7位可得校验位是1,2,4，分别设为p0,p1,p2则:
p0=1⊕0⊕1=0
p1=1⊕0⊕1=0
p2=0⊕0⊕1=0
其中p0、p2有错
p0鉴别的是3、5、7
p1鉴别的是3、6、7
p2鉴别的是5、6、7
由此可得有错的是第五位
</div></code></pre>
</li>
</ul>

</body>
</html>
