<!DOCTYPE html>
<html>
<head>
<title>10.软件工程.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #ff0000; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">软件工程</h1>
<h2 id="%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B">软件开发模型</h2>
<ul>
<li>
<h3 id="%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8Bsdlc">瀑布模型(SDLC)</h3>
<img src="./p83.svg" width="400">
<p>定义阶段：<strong>软件设计</strong>和<strong>需求分析</strong><br>
开发阶段：<strong>软件设计</strong>，<strong>程序编码</strong>和<strong>软件测试</strong>
维护阶段：<strong>运行维护</strong></p>
<p>存在的问题：需求分析难以把控，出现需求问题需要重新回到需求分析</p>
<p><mark><strong>瀑布模型适用场景：需求明确</strong></mark></p>
</li>
<li>
<h3 id="%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%BC%94%E5%8C%96%E6%A8%A1%E5%9E%8B">原型模型和演化模型</h3>
<img src="./p84.svg" width="300">
<p><mark><strong>原型强调构造一个简易的系统，针对需求不明确的情况</strong></mark><br>
<mark><strong>通过原型来获取需求(原型交互)</strong></mark><br>
演化模型是从原型发展而来，即演化原型成为最终的产品<br>
螺旋模型虽然也是从原型发展而来，但是其兼具瀑布模型的特征和演化模型的特征</p>
</li>
<li>
<h3 id="%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B">增量模型</h3>
<p>增量模型兼具瀑布模型和原型的特点，<mark><strong>一步一步执行</strong></mark>，可以把待开发的软件系统模块化，将每个模块作为一个增量组件，<mark><strong>从而分批次地分析、设计、编码和测试这些增量组件</strong></mark>
<br><br><br><br></p>
</li>
<li>
<h3 id="%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B">螺旋模型</h3>
<p><mark><strong>兼具多个模型的特点</strong></mark>，大致分为制定计划、风险分析、实施工程和客户评估这几个方面<mark><strong>（引入了风险分析这个环节，其它模型都没有，是螺旋模型最显著的特征）</strong></mark></p>
</li>
<li>
<h3 id="v%E6%A8%A1%E5%9E%8B">V模型</h3>
<img src="./p85.png" width="400">
<p>特点：</p>
<ul>
<li><mark><strong>经过四重测试</strong></mark>，包括单元测试、集成测试、系统测试和验收测试</li>
<li>在需要分析阶段就进行验收测试和系统测试，在概要设置阶段进行集成测试，在详细设计阶段进行单元测试，<mark><strong>即提前测试</strong></mark></li>
</ul>
</li>
<li>
<h3 id="%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B">喷泉模型</h3>
<p>特点：<br>
<mark><strong>面向对象，迭代且无间隙</strong></mark></p>
</li>
<li>
<h3 id="rad%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B">RAD(快速开发模型)</h3>
<p>使用SDLC（瀑布模型）和CBSD（构建组建模型组成）</p>
<p>特点：
<mark><strong>快速构建应用系统</strong></mark></p>
</li>
<li>
<h3 id="cbsd">CBSD</h3>
<img src="./p86.png" width="300">
<p>把软件中模块组成标准的构建，构件进行组装</p>
<p>特点：<br>
<mark><strong>极大提高软件开发的复用性，极大节约开发的总时长，增加软件可靠性，节省成本</strong></mark>
<br><br><br><br></p>
</li>
<li>
<h3 id="%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95">敏捷开发方法</h3>
<img src="./p87.png" width="450">
<p>特点：<br>
<mark><strong>适用于小型项目，强调小步</strong></mark></p>
</li>
</ul>
<h2 id="%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95">信息系统开发方法</h2>
<ul>
<li>
<h3 id="%E7%BB%93%E6%9E%84%E5%8C%96%E6%B3%95">结构化法：</h3>
<p>特点：</p>
<ul>
<li>用户至上</li>
<li>严格区分工作阶段，每阶段有任务和成果</li>
<li>强调系统开发过程的整体性和全局性</li>
<li>系统开发过程工程化，文档资料标准化</li>
<li>自顶向下，逐步分解（求精）</li>
</ul>
<p>缺点：</p>
<ul>
<li>灵活性比较差
<br><br></li>
</ul>
</li>
<li>
<h3 id="%E5%8E%9F%E5%9E%8B%E6%B3%95">原型法：</h3>
<p>特点：</p>
<ul>
<li><mark><strong>适用于需求不明确的开发</strong></mark></li>
<li>包括抛弃式原型和演化式原型
<br><br></li>
</ul>
</li>
<li>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</h3>
<p>特点：</p>
<ul>
<li><mark>更好的<strong>复用性</strong>(与结构化法相对应)</mark></li>
<li>关键在于建立一个全面、合理、统一的模型</li>
<li>分析、设计、实现三个阶段，需求和界限不明确
<br><br><br><br></li>
</ul>
</li>
<li>
<h3 id="%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%B3%95">面向服务方法</h3>
<ul>
<li>SO方法主要有三个主要的抽象级别：操作、服务和业务流程</li>
<li>SOAD氛围三个层次：基础设计层（底层服务构件）、应用结构 层（服务之间的接口和服务级协定）和业务组织层（业务流程建模和服务流程编排）</li>
<li>服务建模：分为服务发现、服务规约和服务实现三个阶段</li>
</ul>
</li>
</ul>
<h2 id="%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91">需求开发</h2>
<ul>
<li>
<h3 id="%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E5%92%8C%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96">需求分类和需求获取</h3>
<p>分类：</p>
<ul>
<li>业务需求</li>
<li>用户需求</li>
<li>系统需求
<ul>
<li>功能需求</li>
<li>性能需求</li>
<li>设计约束(比如设计语言)
<br><br></li>
</ul>
</li>
</ul>
<p>质量功能展开（顾客驱动产品开发方法）：</p>
<ul>
<li>基本需求（用户明确提出）</li>
<li>期望需求（用户没有明确提出，但是理所应当的需求）</li>
<li>兴奋需求（用户没有明确提出，比较新鲜的需求，但是需要严格控制）</li>
</ul>
</li>
</ul>
<h2 id="%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1">结构化设计</h2>
<ul>
<li>
<h3 id="%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">基本原则</h3>
<ul>
<li>自顶向下，逐步求精</li>
<li>信息隐蔽</li>
<li>模块独立<mark><strong>（高内聚、低耦合、复杂度）</strong></mark><br>
<strong><code>（模块不独立会导致修改复杂）</code></strong></li>
</ul>
<p>其它原则：</p>
<ul>
<li>保持模块的大小适中</li>
<li>尽可能减少调用的深度（防止因为多层调用修改不变）</li>
<li>多扇入，小扇出<mark><strong>（多被调用，少调用其它模块）</strong></mark></li>
<li>单入口，单出口</li>
<li>模块的作用域应该在模块之内</li>
<li>功能应该可预测
<br><br></li>
</ul>
</li>
<li>
<h3 id="%E5%86%85%E8%81%9A%E5%92%8C%E8%80%A6%E5%90%88">内聚和耦合</h3>
<p>内聚指的是一个模块内部之间的紧密程度（<mark>越高越好</mark>）<br>
内聚类型排序（高内聚到低内聚）:<br>
功能内聚&gt;顺序内聚&gt;通信内聚&gt;过程内聚&gt;瞬时内聚（时间内聚）&gt;逻辑内聚&gt;偶然内聚（巧合内聚）</p>
<p>耦合指的是不同模块外部之间的紧密程度（<mark>越低越好</mark>）<br>
耦合类型排序（低耦合到高耦合）:<br>
非直接耦合&gt;数据耦合&gt;标记耦合&gt;控制耦合&gt;外部耦合&gt;公共耦合&gt;内容耦合</p>
</li>
<li>
<h3 id="%E5%8F%98%E6%8D%A2%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">变换型系统结构</h3>
<img src="./p88.png" width="300">
</li>
</ul>
<h2 id="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95">软件测试</h2>
<ul>
<li>
<h3 id="%E6%B5%8B%E8%AF%95%E5%8E%9F%E5%88%99">测试原则</h3>
<ul>
<li>尽早、不断地测试</li>
<li>程序猿避免测试自己设计的程序</li>
<li>既要选择有效、合理的数据，也要选择无效、不合理的数据</li>
<li>修改后进行回归测试（修改bug之后重新测试）</li>
<li>尚未发现的错误数量与该程序已发现错误数成正比（重点测试bug多的模块）</li>
</ul>
</li>
<li>
<h3 id="%E6%B5%8B%E8%AF%95%E7%9A%84%E7%B1%BB%E5%9E%8B">测试的类型</h3>
<p>分为动态测试和静态测试，其中动态测试指的是利用到计算机，而静态测试没有利用到计算机</p>
<ul>
<li>动态测试：
<ul>
<li>黑盒测试法</li>
<li>白盒测试法</li>
<li>灰盒测试</li>
</ul>
</li>
<li>静态测试：
<ul>
<li>桌前检查（自己浏览检查）</li>
<li>代码走查（人工执行）</li>
<li>代码审查（交叉人员检查）</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1">测试用例设计</h3>
<ul>
<li>黑盒测试法（不知道程序结构）
<ul>
<li>等价类划分（用不同的数值类别测试，同一类选择一个进行测试）</li>
<li>边界值分析（测试边界值，在数值中&gt;和≥区别）<pre class="hljs"><code><div>例：要求输入年龄范围是0～150的整数，那么测试边界的数应该有___
</div></code></pre>
<pre class="hljs"><code><div>解：-1、0、1、149、150、151
</div></code></pre>
</li>
<li>错误推测（通常需要经验，推测可能出现问题的地方）</li>
<li>因果图（通过结果推测问题）</li>
</ul>
</li>
<li>白盒测试法（知道程序的内部结构）
<ul>
<li>基本路径俄式</li>
<li>循环覆盖测试</li>
<li>逻辑覆盖测试
<ul>
<li><mark><strong>语句覆盖（所有语句都要被执行）</strong></mark></li>
<li><mark><strong>判定覆盖</strong></mark></li>
<li><mark><strong>条件覆盖（判断条件中所有分支都要覆盖）</strong></mark></li>
<li>条件判断覆盖</li>
<li>修正的条件判断覆盖</li>
<li>条件组合覆盖</li>
<li>点覆盖</li>
<li>边覆盖</li>
<li>路径覆盖</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>例：下图程序流程中如果要通过语句覆盖和判定覆盖测试，分辨需要测试哪些步骤
</div></code></pre>
<img src="./p89.png" width="200">
<pre class="hljs"><code><div>解：
语句覆盖：1→2→3和1→4→5→6→7即可
判定覆盖：1→2→3、1→4→3、1→2→6→7和1→4→5→6→7
</div></code></pre>
</li>
<li>
<h3 id="%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5">测试阶段</h3>
<ul>
<li>单元测试（模块功能的测试）</li>
<li>集成测试（各个模块联合在一起测试，即测试模块合作）
<ul>
<li>一次性组装</li>
<li>增量组装（逐步组装测试）</li>
</ul>
</li>
<li>确认测试（确认需求测试）
<ul>
<li>内部确认测试</li>
<li>Alpha测试（实验室测试)</li>
<li>Beta测试</li>
<li>验收测试（用户参与测试）</li>
</ul>
</li>
<li>系统测试（压力、性能、可靠性方面测试）
<ul>
<li>负载测试（不同负载下性能表现）</li>
<li>强度测试（在系统异常情况下表现）</li>
<li>压力测试（在级限制情况下表现）</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="mccabe">McCabe</h3>
<p>假设在一个图中有m个有向线段，b是图中的结点个数，那么<mark><strong>环路复杂度V(G)=m-n+2</strong></mark></p>
<p>将流程图转换为图：注意分岔全部转换为结点</p>
<img src="./p90.png" width="500">
</li>
</ul>
<h2 id="%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E4%B8%8E%E7%BB%B4%E6%8A%A4">系统运行与维护</h2>
<ul>
<li>可维护性
<ul>
<li>易分析性（可分析性，&lt;<mark><strong>需要编码结构规范</strong></mark>）</li>
<li>易改变性（可改变性，<mark><strong>修改代码的难易程度，通常由耦合程度决定</strong></mark>）</li>
<li>稳定性</li>
<li>易测试性（可测试性）</li>
</ul>
</li>
<li>维护类型
<ul>
<li>改正性维护（25%，<mark><strong>软件开发的瑕疵，用户发现后改正的维护</strong></mark>）</li>
<li>适应性维护（20%，<mark><strong>通常指的是对系统的适应</strong></mark>）</li>
<li>完善性维护（50%，<mark><strong>扩充性能和完善功能</strong></mark>）</li>
<li>预防性维护（5%，<mark><strong>现在不会出现的问题但是以后可能会出现问题或者容易维护的维护</strong></mark>）
<br><br><br><br><br><br><br><br><br><br><br><br></li>
</ul>
</li>
</ul>
<h2 id="%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B">软件过程改进</h2>
<ul>
<li>
<h3 id="cmmi">CMMI</h3>
<p>（能力成熟度模型集成）</p>
<ul>
<li>阶段（组织能力成熟度）<table>
<tr>
  <td width="80"><b>成熟度等级</b></td>
  <td><b>过程域</b></td>
</tr>
<tr>
  <td>混乱</td>
  <td>——</td>
</tr>
<tr>
  <td>已管理级</td>
  <td>需求管理、项目计划、配置管理、项目监督和控制、供应商合同管理、度量和分析、过程和产品质量保证</td>
</tr>
<tr>
  <td>已定义级</td>
  <td>需求开发、技术解决方案、产品集成、验证、确认、组织级过程焦点、组组织级培训、集成项目管理、风险管理、集成化的团队、决策分析和解决方案、组织级集成环境</td>
</tr>
<tr>
  <td>定量管理级</td>
  <td>组织级别过程性能、定量项目管理</td>
</tr>
<tr>
  <td>优化级</td>
  <td>组织级改革与实施、因果分析和解决方案</td>
</tr>
</table>
</li>
<li>连续式（软件过程能力）<table>
<tr>
  <td width="80">连续式分组</td>
  <td>过程域</td>
</tr>
<tr>
  <td>过程管理</td>
  <td>组织级过程焦点、组织级过程定义、组织级培训，组织级过程性能、组织级改革与实施</td>
</tr>
<tr>
  <td>项目管理</td>
  <td>项目计划、项目监督与控制、供应商合同管理、集成项目管理、风险管理、集成化的团队、定量项目管理</td>
</tr>
<tr>
  <td>工程</td>
  <td>需求管理、需求开发、技术解决方案、产品集成、验证、确认</td>
</tr>
<tr>
  <td>支持</td>
  <td>配置管理、度量和分析、过程和产品质量保证、决策分析和解决方案、组织级集成环境、因果分析和解决方案</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
<h2 id="%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">项目管理</h2>
<p>九大知识领域</p>
<ul>
<li>范围管理</li>
<li><mark><strong>时间管理</strong></mark></li>
<li>成本管理</li>
<li>质量管理</li>
<li>人力资源管理</li>
<li>沟通管理</li>
<li><mark><strong>风险管理</strong></mark></li>
<li>采购管理</li>
<li>整体管理</li>
</ul>
<p><br><br><br><br></p>
<ul>
<li>
<h3 id="%E7%94%98%E7%89%B9%E5%9B%BEgantt%E5%9B%BE%E5%92%8Cpert%E5%9B%BE">甘特图(Gantt图)和PERT图</h3>
<p>甘特图(Gantt图)，例如下图所示<br>
<img src="./p92.jpg" width="400"><br>
优点：<br>
甘特图反映了时间和任务的规律，图形化概要，通用技术，易于理解。<br>
缺点：<br>
具有局限性，没有明确不同任务之间的依赖关系</p>
<p>PERT图，例如下图所示<br>
<img src="./p93.png" width="400"><br>
优点：<br>
明确不同任务之间的依赖关系<br>
缺点：<br>
没有明确时间和任务的关系</p>
<pre class="hljs"><code><div>进度安排的常用图形描述方法有Gantt图和PERT图。Gantt图不能清晰地描述___；PERT图可以给出哪些任务完成之后才能开始另一些任务。下图所示的PERT图中，事件6的最晚开始时间为___
1.
A.每个任务从何开始      B.每个任务到何时结束
C.每个任务的进展情况    D.每个任务之间的依赖关系
2.
A.0     B.3
C.10    D.11
</div></code></pre>
<img src="./p91.png" width="400">
<pre class="hljs"><code><div>解：
1.D
2.先正推，推得最早完成时间为15
</div></code></pre>
<img src="./p94.png" width="400">
<pre class="hljs"><code><div>逆推，得到答案C
</div></code></pre>
<img src="./p95.png" width="400">
</li>
</ul>
<p><br><br><br><br><br><br><br></p>
<ul>
<li>
<h3 id="%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86">风险管理</h3>
<p>指的是损失或者损害的可能性</p>
<p>风险的类别：</p>
<ul>
<li>项目风险（例如预算问题产生的风险）</li>
<li>技术风险（例如技术不成熟或者陈旧导致不可控的风险）</li>
<li>商业风险（例如产品不符合市场需求）</li>
</ul>
<p>风险曝光度：<mark><strong>风险出现的概率 x 风险可能造成的损失</strong></mark></p>
</li>
</ul>

</body>
</html>
